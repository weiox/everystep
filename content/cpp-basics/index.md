---
title: "C++ 基础专栏大纲"
description: "面向学过 C 语言的读者，帮助你在 C 的基础上建立对 C++ 的宏观认知，并能用 C++ 直接写实际项目。"
---

这个专栏主要面向**已经学过一轮 C 语言**的读者（比如大一刚上完 C 课，或者用 C 写过一些小项目），希望在此基础上**看清 C++ 这门语言到底多了些什么、又想解决什么问题，并在读完之后可以直接用 C++ 去写实际的小工具和业务代码**，而不是只会把 C 代码丢进 `.cpp` 里编译。

我们不会事无巨细地罗列每一个语法点，而是聚焦于：从你已经掌握的 C 出发，**哪些新的概念和设计，会直接影响你写 C++ 程序的方式**——这些是你“只会 C，还不会 C++”时最值得优先补上的那一小撮知识。

---

## 第一部分：类型与函数

在 C 里，你已经习惯了 `int`、`double`、`struct` 这些基本类型和普通的函数调用。但在 C++ 里：

- 类型系统被用来表达更多约束（比如 `const`、引用、强类型别名）；
- 函数的“签名”被当作一种设计工具，而不只是“能不能通过编译”。

- [x] **[C++ 类型系统速览：从 int 到 auto](./cpp-type-system-overview.md)**
    - 从整体视角理解 C++ 类型系统：与 C 的差异、与 Java/Python 等语言的对比、静态 vs 动态的取舍，以及如何用 auto、const 和自定义类型在编译期表达约束。

- [x] **[函数：逻辑的基本单元](./cpp-functions-basics.md)**
    - 从“为什么要抽函数”出发，梳理函数在源码、编译器和链接器中的角色，理解函数签名、声明与定义的区分，为后续一系列接口设计话题打基础。

- [x] **[参数传递：值、指针、引用怎么选？](./cpp-parameter-passing.md)**
    - 通过 `swap` 这个经典大坑，拆开值传递、指针传递和引用传递的差别，用“会不会改、能不能为空、是否只读”这些直觉来帮你选参数类型。

- [x] **[重载与默认参数：让接口更灵活](./cpp-overload-default-args.md)**
    - 从 `abs`、`average` 等例子出发，讲清重载决议规则、为什么返回类型不能单独区分重载，以及默认参数和重载各自适合的使用场景。

- [x] **[从 struct 到 class：C++ 面向对象的最小子集](./cpp-struct-to-class.md)**
    - 站在 C 风格 struct 的视角，认识 C++ 中 struct/class 的关系、构造函数与析构函数的基本角色，以及“对象 + RAII”这一整套最小面向对象观念，不在本专栏展开复杂的继承与多态细节。

---

## 第二部分：指针与内存

在 C 课上，你已经接触过指针，但很多时候只是“照着写能跑起来”。

这一部分的目标，是在 C 的指针基础上，帮你真正建立起一幅**内存模型的心智图**：

- 内存可以怎样被抽象成一条“地址线”；
- 栈上的局部变量和堆上的动态分配有何不同；
- 为什么在 C++ 里，“值语义”和“引用语义”会对接口设计产生巨大影响。

- [x] **[指针入门：从内存地址到指针操作](./cpp-pointers-basics.md)**
    - 内存地址的概念、`*` 与 `&` 操作符、指针的算术运算。

- [x] **[栈与堆：理解 C++ 的内存世界](./cpp-stack-heap.md)**
    - 局部变量的生命周期、new/delete、为什么会有内存泄漏、值语义 vs 引用语义。

- [x] **[std::string 的“六宗罪”：C++ 最常用类的隐藏陷阱](./std-string-pitfalls.md)**
    - 站在性能视角拆解 `std::string` 的实现细节（SSO、内存分配、临时对象等），帮助你在真实项目里用对而不是滥用它。

- [x] **[揭秘 Redis 字符串：C++ 程序员的面试加分项 SDS](./sds-intro.md)**
    - 借 Redis 的 SDS 设计，重新审视 C 字符串的历史包袱，理解“长度 + 剩余空间”这套内存布局如何在工程里解决性能与安全问题。

- [x] **[`string_view` 现身之前：C++各大门派的“零拷贝”往事](./string-view-precursors.md)**
    - 回顾 Google StringPiece、LevelDB Slice、Qt QStringRef 等经典实现，看 C++ 社区如何在标准化 `std::string_view` 之前探索“零拷贝字符串视图”这条路。

---

## 第三部分：编译与链接

在 C 里，你大概已经见过“头文件 + 源文件 + 编译/链接”这一套，但很多课程只是略带一提。

这一部分会从 C 再往前走一步，系统性地梳理：

- 头文件存在的真正原因是什么；
- `#include` 在预处理阶段到底做了什么；
- 为什么“只有一个定义”（ODR）会变成 C++ 项目里经常踩到的坑。

- [x] **[声明与定义：代码为什么要拆成两份？](./cpp-declaration-definition.md)**
    - 从“未声明的标识符”报错出发，讲清声明与定义的语法区别、头文件存在的真正理由，以及单一定义规则（ODR）是如何从编译/链接模型中自然长出来的。

- [x] **[编译与链接：代码如何变成程序](./cpp-compile-link.md)**
    - `#include` 的本质、头文件与源文件分离、翻译单元与链接过程的整体视图。

- [x] **[命名空间 (namespace) 详解](./cpp-namespace-guide.md)**
    - 命名冲突的根源、嵌套命名空间、版本控制 (inline namespace)。

- [x] **[匿名命名空间详解](./cpp-anonymous-namespace.md)**
    - 替代 `static` 的现代方案、内部链接、隐藏实现细节。

---

> **读完这个专栏后**，你应该能在脑中形成这样一幅图景：
>
> - 在 C 的类型和指针之上，C++ 如何用类型系统表达更多约束；
> - C/C++ 共用的内存与编译模型里，哪些是 C++ 程序员必须特别在意的部分；
> - 为什么一提到资源管理，C++ 社区总在强调 RAII 和“不要自己到处写 delete/free”。
> - 在遇到实际的小项目或业务需求时，能够自觉地选用 C++ 的基本工具（类、RAII、命名空间等），而不是继续用“C 写法”硬撑。
>
> **下一步**：继续阅读 **[Modern C++](/docs/cpp-modern)** 专栏，学习 C++11 ~ C++26 的新特性和更深入的技术细节。