---
title: "C++ 指针入门：从内存地址到指针操作"
description: "深入理解 C++ 指针的核心概念，掌握内存地址、指针运算及常见陷阱。"
order: 20
---

指针（Pointer）是 C++ 中最强大也最令人敬畏的特性之一。它是理解计算机底层工作原理的钥匙，也是高效操作内存的利器。对于初学者来说，指针可能显得有些抽象，但只要理解了它的本质——**内存地址**，一切就会豁然开朗。

### 1. 内存与地址：一切的起点

想象一下，计算机的内存就像一条长长的街道，街道上有一排排的房子。
*   **内存单元**：每一个房子就是一个内存单元（通常是 1 字节）。
*   **地址（Address）**：每一个房子都有一个唯一的门牌号，这就是内存地址。
*   **数据**：房子里住的人（或存放的物品），就是变量存储的值。

当你定义一个变量时：
```cpp
int age = 18;
```
计算机会在内存这条街上找一个空房子（或者连续的几个房子，因为 `int` 通常占 4 字节），把 `18` 这个值放进去，并记下这个房子的门牌号（地址）。

### 2. 什么是指针？

**指针就是一个变量，只不过它存放的不是普通的数值，而是另一个变量的内存地址（门牌号）。**

*   **普通变量**：存的是数据（如 18, 3.14, 'A'）。
*   **指针变量**：存的是地址（如 0x7ffee1）。

### 3. 声明与初始化

#### 声明指针
指针的类型必须与它指向的变量类型一致。符号 `*` 用于声明指针。

```cpp
int* p1;    // 指向 int 的指针
double* p2; // 指向 double 的指针
char* p3;   // 指向 char 的指针
```

#### 获取地址 (`&`)
使用取地址运算符 `&` 可以获取一个变量的地址。

```cpp
int age = 18;
int* ptr = &age; // ptr 现在存放了 age 的地址
```

#### 打印地址
```cpp
#include <iostream>

int main() {
    int age = 18;
    int* ptr = &age;

    std::cout << "age 的值: " << age << std::endl;
    std::cout << "age 的地址: " << &age << std::endl;
    std::cout << "ptr 的值: " << ptr << std::endl; // ptr 的值就是 age 的地址

    return 0;
}
```

### 4. 解引用 (`*`)：通过指针访问数据

既然指针存了地址，我们就可以通过这个地址找到"房子"里存的数据。这个过程叫**解引用（Dereferencing）**，使用的也是 `*` 符号（注意这里是运算符，不是声明）。

```cpp
int main() {
    int age = 18;
    int* ptr = &age;

    // 读取数据
    std::cout << "通过指针访问 age: " << *ptr << std::endl; // 输出 18

    // 修改数据
    *ptr = 20; // 相当于 age = 20
    std::cout << "修改后的 age: " << age << std::endl; // 输出 20

    return 0;
}
```

> **区分 `*` 的两种含义：**
> *   `int* ptr;` —— 声明时，表示 `ptr` 是一个指针类型。
> *   `*ptr = 10;` —— 使用时，表示操作 `ptr` 指向的那块内存。

### 5. 空指针：nullptr vs NULL

在使用指针时，如果它暂时不指向任何有效的内存，我们应该将其初始化为空指针。

*   **C++11 之前**：使用 `NULL`（本质通常是整数 0）。
*   **C++11 及以后**：强烈推荐使用 **`nullptr`**。

`nullptr` 是类型安全的空指针常量，它明确表示"这是一个指针，不指向任何对象"，避免了整数 0 带来的歧义。

```cpp
int* p1 = nullptr; // 推荐
int* p2 = NULL;    // 不推荐（旧式写法）
int* p3 = 0;       // 不推荐
```

**安全准则**：在解引用指针前，永远要检查它是否为空。
```cpp
if (ptr != nullptr) {
    std::cout << *ptr << std::endl;
}
```

### 6. 指针与数组

在 C++ 中，数组名在很多情况下会**退化（decay）**为指向数组首元素的指针。

```cpp
int arr[] = {10, 20, 30};
int* p = arr; // 等价于 int* p = &arr[0];

std::cout << *p << std::endl;       // 输出 10
std::cout << *(p + 1) << std::endl; // 输出 20（指针运算）
```

#### 指针运算
*   `p + 1`：并不是地址数值加 1，而是向后移动**一个元素大小**的距离（如果是 `int*`，通常地址 +4）。
*   `p[i]`：等价于 `*(p + i)`。

### 7. 常见陷阱：悬空指针与野指针

*   **野指针 (Wild Pointer)**：未初始化的指针。它的值是随机的垃圾值，指向未知的内存区域。
    ```cpp
    int* p; // 野指针！千万别解引用
    // *p = 10; // 崩溃！
    ```
    **对策**：声明指针时要么初始化为有效地址，要么设为 `nullptr`。

*   **悬空指针 (Dangling Pointer)**：指向的内存已经被释放了，但指针还在。
    ```cpp
    int* func() {
        int a = 10;
        return &a; // 危险！a 是局部变量，函数结束就销毁了
    } // 返回的指针指向无效内存
    ```
    **对策**：不要返回局部变量的地址；对象释放后，及时将指针置为 `nullptr`。

### 8. 总结

*   指针是存储内存地址的变量。
*   `&` 取地址，`*` 解引用（取值）。
*   始终初始化指针，推荐使用 `nullptr`。
*   理解指针与数组的紧密联系。

掌握指针是迈向高级 C++ 编程（如动态内存管理、多态、智能指针）的第一步。