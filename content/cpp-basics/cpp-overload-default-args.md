---
title: "重载与默认参数：让接口更灵活"
description: "讲清楚函数重载的规则（为什么返回类型不能区分重载），以及默认参数如何简化接口设计。"
order: 24
---

在 C 语言里，如果你想给不同类型写"求绝对值"函数，通常只能老老实实起不同的名字。  
在 C++ 里，你可以让多个函数共享同一个名字，只靠参数列表来区分——这就是**函数重载**。

另外，有些函数天然有一个"最常见的用法"。**默认参数**让你可以省略那些"大部分时候都一样"的参数。

这篇文章会讲清楚：

- 重载是怎么工作的？
- 为什么返回类型不能用来区分重载？
- 默认参数的规则和注意事项
- 重载 vs 默认参数，什么时候用哪个？

---

## 函数重载

### 在 C 里的痛点

在 C 语言里，如果你想给不同类型写"求绝对值"函数，通常只能老老实实起不同的名字：

```cpp
int abs_int(int x) {
    return (x >= 0) ? x : -x;
}

double abs_double(double x) {
    return (x >= 0) ? x : -x;
}
```

调用的时候，只能记住自己当前用的是哪个版本：

```cpp
int    ai = abs_int(-5);
double ad = abs_double(-3.14);
```

从机器的角度看，这完全没问题；但从人类的角度看就有点啰嗦了。明明是同一件事——"求绝对值"——为什么我要在名字上不断重复类型信息？

### C++ 的解决方案

C++ 给出的答案是：**让函数签名（名字 + 参数类型）而不是"裸名字"来区分不同版本**。

于是我们可以这样写：

```cpp
int abs(int x) {
    return (x >= 0) ? x : -x;
}

double abs(double x) {
    return (x >= 0) ? x : -x;
}
```

这时候，调用就变得非常自然：

```cpp
int    ai = abs(-5);      // 调用的是 int 版本
double ad = abs(-3.14);   // 调用的是 double 版本
```

编译器在看到 `abs(-5)` 时，会根据实参的类型去挑选匹配的签名 `abs(int)`；看到 `abs(-3.14)` 时，又会挑选 `abs(double)`。

这整个过程叫做**重载决议（overload resolution）**。

### 参数个数也能区分

重载不仅可以通过"参数类型不同"来区分，也可以通过"参数个数不同"。

比如写几个"计算平均值"的函数：

```cpp
double average(double a, double b) {
    return (a + b) / 2.0;
}

double average(double a, double b, double c) {
    return (a + b + c) / 3.0;
}
```

调用方可以这么用：

```cpp
double m2 = average(10.0, 20.0);
double m3 = average(10.0, 20.0, 30.0);
```

编译器会根据你给了两个参数还是三个参数，自动选择合适的版本。

### 返回类型不能区分重载

需要特别小心理解的一点是：**返回类型不能用来区分重载**。

下面这样的两个声明，不能同时出现：

```cpp
int    parse(const std::string& text);
double parse(const std::string& text);  // 错误：仅仅返回类型不同
```

原因也很直观：如果你只是写了 `parse("123")` 而没有接收返回值，编译器根本没法知道你到底想要 `int` 还是 `double` 版本。

所以在 C++ 里，一个函数的"签名"只看**名字 + 参数类型列表**，不看返回类型。

### 重载的设计原则

从设计的角度看，好的重载应该是**"同一件事的不同形态"**。

比如：

- `abs(int)` 和 `abs(double)` —— 都是"求绝对值"
- `print(int)` 和 `print(const std::string&)` —— 都是"打印"
- `average(a, b)` 和 `average(a, b, c)` —— 都是"求平均值"

如果两个函数的行为在语义上已经完全不同，哪怕参数列表刚好也不同，也不应该硬塞到同一个名字下面，否则读代码的人会很痛苦。

---

## 默认参数

### 动机

有些函数天然有一个"最常见的用法"。如果每次都把所有参数显式写出来，会显得有点啰嗦。

举个简单的例子：假设你写了一个画直线的函数，允许调用者指定长度和用什么字符来画。

```cpp
void draw_line(int length, char ch) {
    for (int i = 0; i < length; ++i) {
        std::cout << ch;
    }
    std::cout << '\n';
}
```

用法可能是这样的：

```cpp
draw_line(10, '-');
draw_line(5,  '*');
```

如果你观察一下自己的调用习惯，会发现绝大多数时候其实都是用 `'-'` 来画分隔线，只有在少数地方才会换成 `'*'` 或别的字符。

### 默认参数登场

能不能在不写第二个参数的时候，默认就当成 `'-'` 呢？这就是默认参数登场的地方：

```cpp
void draw_line(int length, char ch = '-') {
    for (int i = 0; i < length; ++i) {
        std::cout << ch;
    }
    std::cout << '\n';
}
```

`char ch = '-'` 表示：如果调用方没有显式传 `ch`，那就自动帮他补上 `'-'`。

于是你的调用方式可以多一种简写：

```cpp
draw_line(10);        // 等价于 draw_line(10, '-')
draw_line(5, '*');    // 仍然可以手动指定
```

### 默认参数的规则

使用默认参数需要注意几点规则：

**1. 默认值必须从右往左连续**

```cpp
void foo(int a, int b = 10, int c = 20);  // OK
void foo(int a = 10, int b, int c = 20);  // 错误：b 没有默认值，但左边的 a 有
```

原因很简单：调用时参数是从左往右填的，如果中间有"空洞"，编译器不知道你省略的是哪一个。

**2. 默认值必须在编译期就能确定**

```cpp
void foo(int x = 10);                    // OK：字面量
void foo(int x = some_global_var);       // OK：全局变量（编译期可见）
void foo(int x = compute_something());   // 要小心：函数调用在每次调用时都会执行
```

**3. 头文件 / 源文件分离时，默认参数只写一次**

在有头文件 / 源文件分离的场景下，**默认参数通常只写在声明的那一侧（头文件）**，定义那一侧只写普通的参数列表：

```cpp
// utils.hpp
void draw_line(int length, char ch = '-');  // 声明带默认参数

// utils.cpp
void draw_line(int length, char ch) {       // 定义不重复写默认值
    for (int i = 0; i < length; ++i) {
        std::cout << ch;
    }
    std::cout << '\n';
}
```

这样可以避免两个地方写出不一致的默认值。

### 签名仍然只有一个

从类型系统的角度看，带默认参数的函数仍然只有一个签名 `draw_line(int, char)`。只是编译器在看到少传参数的调用时，会在调用点自动把缺失的实参补上。

这和重载不同——重载是真的有多个不同签名的函数存在。

---

## 重载 vs 默认参数

什么时候用重载，什么时候用默认参数？

### 用默认参数的场景

- 参数有一个"最常见的值"，偶尔才需要改
- 不同调用之间，函数的行为本质上是一样的

```cpp
void log(const std::string& msg, LogLevel level = LogLevel::Info);
```

### 用重载的场景

- 参数类型完全不同
- 不同版本的实现逻辑差异较大

```cpp
void print(int x);
void print(double x);
void print(const std::string& s);
```

### 有时候两者可以互换

比如前面的 `average` 例子，用重载：

```cpp
double average(double a, double b);
double average(double a, double b, double c);
```

也可以用默认参数来模拟（但不太自然）：

```cpp
// 这种写法不太好，因为"第三个参数可选"的语义不清晰
double average(double a, double b, double c = ???);  // c 默认是什么？
```

在这种情况下，重载更清晰。

---

## 小结

回顾一下这篇文章的要点：

**重载**让你可以用同一个名字表达"同一件事的不同形态"：

- 靠参数类型或参数个数来区分
- 返回类型不能用来区分
- 好的重载应该在语义上是同一件事

**默认参数**让你可以把"最常见的用法"固化到签名里：

- 省略的参数会被编译器自动补上默认值
- 默认值必须从右往左连续
- 头文件 / 源文件分离时，只在声明侧写一次

这两个特性都是为了让接口更灵活、调用更自然。选择哪一个，取决于你想表达的语义是"同一件事的多种形态"还是"大部分时候用这个值"。
