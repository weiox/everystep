---
title: "比特与字节：最小存储单位"
description: "把内存想象成一块巨大的数组，从 0 号格子到最后一个格子，每个格子都是 1 字节。"
order: 10
---

很多教材都会用一句话开头：

> bit 是比特，byte 是字节，1 byte = 8 bit。

这句话本身没有问题，只是如果停留在背定义的层面，它对你写 C/C++ 帮助不大。你知道 `sizeof(int)` 通常是 4，知道“占 4 个字节”，也在调试器里见过一排排十六进制数，但脑子里那幅“内存长什么样”的图往往是模糊的。

这一篇我们不打算列公式，而是用你已经熟悉的 C 风格代码和一点点想象力，把“bit / byte / 内存”这三件事串成一幅具体的画面。

---

### 1. 一行简单的 C 代码背后发生了什么？

先从你肯定写过的一行代码开始：

```cpp
char c = 'A';
```

编译器会在内存里给 `c` 找一个位置。为了方便想象，我们先假装内存长这样：

```text
内存（只画出很小一段）：

  地址:   100   101   102   103   104   105   ...
        +-----+-----+-----+-----+-----+-----+
        |     |     |     |     |     |     |
        +-----+-----+-----+-----+-----+-----+
```

你可以把这条横线当作一个巨大的数组，每一个小格子正好是 **1 个字节**。上面标的 `100、101、102...` 就是这些格子的“下标”，在 C 里我们把它叫做“地址”。

当执行到 `char c = 'A';` 这一句时，编译器会挑出其中一个格子，比方说地址是 `100` 的那一格，把字符 `'A'` 的编码写进去，并且在符号表里记一笔：

> 变量名 `c` ——> 使用地址为 100 的这个字节格子。

以后你在代码里写 `c`，就相当于告诉机器：“去地址 100 那一格，把里面那个字节按字符的方式读出来”。

到这里你已经有了第一幅图：

> 内存是一长条由“字节格子”构成的数组，变量就是在这条数组上“占了几个格子”的名字。

---

### 2. 一个字节里面到底放了什么？

接下来，把刚才那个地址为 100 的格子放大来看：

```text
地址 100 这一格：

  +---+---+---+---+---+---+---+---+
  | b7| b6| b5| b4| b3| b2| b1| b0|
  +---+---+---+---+---+---+---+---+
```

这里的 `b0 ~ b7` 就是这一字节里的 8 个 **bit（比特）**，你可以把它们想象成 8 个只能开 / 关的小开关，开代表 1，关代表 0。

如果 `c` 存的是字符 `'A'`，在 ASCII 编码下，它对应的十六进制数是 `0x41`，也就是二进制的：

```text
    0x41 = 0b0100 0001

对应到上面的 8 个小格子，就是：

  +---+---+---+---+---+---+---+---+
  | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 |
  +---+---+---+---+---+---+---+---+
```

同样的 8 个比特，如果把它当整数来解释，就是 65；当字符来解释，就是 `'A'`。

这给我们第二幅图：

> 一个 **字节** 可以理解成“装了 8 个比特的小盒子”，盒子里装的是 0/1 的组合，至于把这 8 个 0/1 当成什么，要看你用什么类型去解释。

---

### 3. 从一个字节到一串字节：短字符串的例子

只看一个字节有点抽象，我们来看一段你更熟悉的代码：

```cpp
char s[] = "Hi";   // 包含结尾的 '\0'
```

这个数组里一共有三个字符：`'H'`、`'i'` 和 `"\0"` 结尾符。编译器可能会把它们放在地址 200 开始的三个格子里：

```text
地址:    200     201     202
        +------+------+------+
内存:   |  H   |  i   | '\0'|
        +------+------+------+
```

如果再把每一个字节展开，就会看到三组 8 个比特：

```text
  'H' -> 0x48 -> 0b0100 1000
  'i' -> 0x69 -> 0b0110 1001
 '\0'-> 0x00 -> 0b0000 0000
```

和前面的 `char c = 'A';` 对照着看，你会发现：

* 内存还是那条字节数组，只不过这次连续用了 3 个格子。
* `s[0]` 就是地址 200 的那一格，`s[1]` 是 201，`s[2]` 是 202。

所以，当我们说“字符串是以 `\0` 结尾的一串字符”时，在内存里的样子其实非常朴素：

> 从某个起点地址开始，一格一格连续往后放 `char`，遇到那一格全为 0 的字节，就当作结束。

以后你在调试器里看到一段内存既能被显示为十六进制字节，又能被显示为 ASCII 字符，其实就是在同一块“字节数组”上换了一副眼镜在看。

---

### 4. 多字节的类型：数“格子”的方式理解 sizeof

现在把视角从 `char` 换到你更关心的 `int` 上。

假设在某个平台上，`sizeof(int)` 恰好是 4。你写了这样一段代码：

```cpp
int a = 1;
int b = 2;
```

编译器可能会这样安排它们在那条“内存数组”上的位置：

```text
地址:    300   301   302   303   304   305   306   307   ...
        +-----+-----+-----+-----+-----+-----+-----+-----+
内存:   |  a 的四个字节  |  b 的四个字节  |  ...
        +-----+-----+-----+-----+-----+-----+-----+-----+
```

这时再来看 `sizeof` 的输出：

```cpp
std::cout << sizeof(a) << "\n";  // 打印 4
```

你就可以把它直接翻译成一句中文：

> `a` 这个变量在那条内存数组上，一共占了 4 个连续的字节格子。

同理，之前的 `char c`，`sizeof(c)` 就是 1，表示只占了 1 个字节格子。

这里我们暂时不去展开“a 的四个字节内部是高位在前还是低位在前”（那是大小端的问题，会在后面的文章里讲），只要先固定这个直觉：

> `sizeof` 告诉你的，就是“这个类型的一个对象，需要在那条内存数组上占多少格子”。

有了这个直觉，结构体、数组、指针运算都会变得好理解很多。

---

### 5. 再看一眼 bit 和 byte 的关系

回过头来，总结一下 bit 和 byte 在这幅图里的位置：

* 整块内存是一条巨大的“字节数组”；
* 每个“数组元素”就是 1 个字节；
* 每个字节内部藏着 8 个 bit，是更细一层的 0/1；
* `sizeof` 数出来的是“有多少个字节元素”，而不是“有多少个 bit”。

如果你愿意再往下拆，可以把整个画面想象成一串嵌套的数组：

```text
内存:   byte MEMORY[N];           // 从地址 0 到地址 N-1，每格 1 字节
字节:   bit  BYTE[8];             // 每个字节里有 8 个 bit
变量:   占用 MEMORY 里的若干连续格子
```

这当然不是 C++ 的真实语法，但作为心智模型已经足够用了。

---

### 6. 小结：以后脑子里该出现什么画面？

以后你再看到“比特 / 字节 / 地址 / sizeof”这些词，希望你的脑子里能自然浮现这样几幅画面：

当你写 `char c = 'A';` 时，某个地址上的一格字节被填上了 `0x41`，它内部的八个 bit 变成了 `0100 0001`；

当你写 `char s[] = "Hi";` 时，从某个起点开始，连续三个字节格子里分别放进了 `'H'`、`'i'` 和 结尾的 `"\0"`；

当你写 `sizeof(s)` 或 `sizeof(int)` 时，其实是在问：“这个东西在那条内存数组上，一共占了多少个字节格子？”

有了这几幅画面，后面我们再去谈“位宽、补码、整数溢出、浮点编码、结构体对齐、大小端”，就不再是空洞的名词，而是都能在这条“内存数组”上找到自己的位置。
