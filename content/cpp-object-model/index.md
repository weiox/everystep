---
title: "C++ 对象模型"
description: "在 C++ 基础之上，系统理解 class/struct、继承、多态与虚函数表，让你敢于在实际项目中设计清晰的接口层次。"
order: 1
---

这个专栏假设你已经读完「C++ 基础」专栏，能够用 C++ 的类、RAII 和命名空间写出小型程序。现在我们不再按“语法点”来组织内容，而是从另一个角度来回答一个核心问题：

> C++ 里的“对象”到底长什么样？
>
> 继承、多态、虚函数这些特性，在**内存布局**和**调用流程**层面究竟做了什么？

我们不会去做 ABI 级别的实现考古，而是以**设计决策**为主线，在刚好足够的实现细节上建立心智模型：

- **对象在内存中是怎样排布的**；
- **不同的继承/多态写法背后，编译器帮你“偷偷”做了哪些事**；
- **这些实现细节反过来如何影响接口设计与代码风格**。

为了降低单篇的阅读压力，本专栏会把每个主题拆成粒度更小的几篇文章，你可以按章节渐进式地构建自己的对象模型心智图。

---

## 导读：为什么还需要一个「对象模型」专栏？

- [ ] **对象模型全景图：从 C struct 到现代 C++** (🚧 计划中)
    - 回顾你在「C++ 基础」中已经掌握的最小面向对象观念，解释“对象模型”这个词在本专栏里的具体含义，以及它和“面向对象编程”的关系与区别。

- [ ] **先修知识与阅读建议** (🚧 计划中)
    - 列出你需要具备的前置知识（指针、RAII、命名空间、基础模板语法等），给出推荐的阅读顺序，以及如何在阅读时配合编译器、调试器和反汇编工具进行“观测实验”。

---

## 第一部分：对象与类的内存布局

在这一部分里，我们只谈“单个对象不带多态”的情况：

- 对象在内存里到底是一块怎样的“连续区域”；
- 成员变量为什么会因为对齐与填充而改变对象大小；
- `this` 指针与成员函数之间的真实关系；
- 构造函数与析构函数如何改变“对象的有效状态”。

- [ ] **从 C struct 到 C++ class：对象就是一块“带标签的内存”** (🚧 计划中)
    - 从最简单的 POD `struct` 出发，理解“对象 = 一块特定类型的内存”，并对比 C 与 C++ 在对象概念上的延展（构造/析构、访问控制等）。

- [ ] **成员变量布局与内存对齐：对象大小为什么和你想的不一样？** (🚧 计划中)
    - 通过几个小例子，拆解成员顺序、对齐要求、填充字节（padding）等因素如何共同决定对象大小，并讨论在实际项目中是否有必要“手工排列成员”。

- [ ] **this 指针与成员函数的本质：语法糖背后发生了什么？** (🚧 计划中)
    - 解释 `this` 指针从哪里来、成员函数如何在 ABI 层面被实现成普通函数 + 隐式参数，以及这对 `const` 成员函数、链式调用等语法有什么影响。

- [ ] **构造函数、析构函数与对象状态：从“未构造”到“已销毁”** (🚧 计划中)
    - 区分“内存被分配”与“对象被构造”这两个阶段，理解编译器在不同路径下插入构造/析构调用的规则，以及为什么异常安全会和对象生命周期紧密相关。

---

## 第二部分：接口类与继承层次

当你需要“抽象出一套接口”时，并不一定非要用继承。这一部分会先对比没有继承时的做法，再逐步引入接口类与虚函数：

- C 风格的“函数指针回调 / 策略表”如何组织代码；
- 纯虚函数、`virtual`、`override`、虚析构函数各自解决什么痛点；
- 什么时候用继承表达“is-a”，什么时候用组合表达“has-a”。

- [ ] **没有继承时怎么做抽象：函数指针、回调与策略表** (🚧 计划中)
    - 用日志后端或排序策略等简单例子，展示如何在 C 里通过函数指针和结构体组合出“接口表”，以及这种写法在类型安全与可读性上的局限。

- [ ] **最小接口类：纯虚函数与 virtual 关键字到底干什么** (🚧 计划中)
    - 从一个 C 风格策略表出发，重写成最小的 C++ 接口类，逐条解释 `virtual`、纯虚函数、`override` 出现的动机，以及“非虚函数 + 继承”可能导致的坑。

- [ ] **继承 vs 组合：IS-A 和 HAS-A 的边界** (🚧 计划中)
    - 总结几类常见的误用继承场景（如为了代码复用而滥用基类），给出一套判断准则：什么时候应该用组合，什么时候用继承，以及如何在接口设计评审中说清这些理由。

- [ ] **接口类与资源管理：为什么几乎总要虚析构？** (🚧 计划中)
    - 结合 RAII，说明接口类的析构函数为什么通常要是虚函数，`unique_ptr<Base>` 与 `shared_ptr<Base>` 在多态场景下分别适合什么情况，以及什么时候可以不把析构函数设为 `virtual`。

---

## 第三部分：虚函数表与动态多态

理解虚函数表（vtable）并不是为了记住所有实现细节，而是为了在设计接口时做到心里有数：

- 动态多态是如何通过“间接调用”实现的；
- 对象里多出来的“vptr 指针”意味着什么；
- 多重继承与菱形继承在布局上的复杂度会如何反噬可维护性。

- [ ] **虚函数表长什么样：vptr 与 vtable 的心智模型** (🚧 计划中)
    - 不依赖特定 ABI，构建一幅“对象 + vptr + vtable”的概念示意图，解释单继承情况下虚函数表的大致结构，以及如何用调试器/反汇编工具一窥实际实现。

- [ ] **从调用点到 vtable：`Base* p = new Derived; p->foo();` 发生了什么？** (🚧 计划中)
    - 围绕这行经典代码，按时间线追踪编译器生成的代码：构造时如何写入 vptr，调用时如何通过 vptr 查表，再到最终跳转到实际函数，实现虚函数调用的“编译期/运行期分工”。

- [ ] **对象切片与指针/引用：多态为什么总和“间接访问”绑在一起？** (🚧 计划中)
    - 解释对象切片（object slicing）的成因，为什么多态通常要求通过指针或引用来使用，以及在接口设计中如何避免因为值传递而悄悄丢失多态行为。

- [ ] **多重继承与菱形继承的布局成本** (🚧 计划中)
    - 概述多重继承下对象布局与 vtable 的复杂度，说明虚继承（virtual inheritance）在解决菱形继承问题时引入了哪些额外 indirection，并给出实务层面“能不用就不用”的设计建议。

---

## 第四部分：多态的边界与替代方案

动态多态（虚函数）不是 C++ 里唯一的多态形式。模板与泛型编程提供了另一条路线。本部分会聚焦在“选型”而非语法细节：

- 运行时多态与模板多态在性能、编译时间和二进制边界上的取舍；
- 如何用同一个小例子（如日志/渲染后端）写出两种风格的代码；
- 如何在项目早期就做出相对稳健的设计决策。

- [ ] **运行时多态的成本：间接调用、缓存与 ABI 边界** (🚧 计划中)
    - 从 CPU 缓存与分支预测的角度理解虚函数调用的代价，并讨论在动态库边界暴露接口类时需要考虑的 ABI 稳定性问题。

- [ ] **模板多态：在编译期“长出”不同的实现** (🚧 计划中)
    - 用一个简单的策略模式例子，展示如何用模板参数替代虚函数，实现“零运行时开销”的多态，同时指出模板带来的编译时间与可读性成本。

- [ ] **策略模式的两种写法：虚函数接口 vs 模板参数** (🚧 计划中)
    - 并排对比两种实现：以日志后端或渲染后端为例，从扩展新后端的难度、调用方代码的简洁度、二进制体积等维度分析各自优劣。

- [ ] **实战选型清单：在真实项目里怎么选？** (🚧 计划中)
    - 给出一份可操作的决策清单：根据“是否跨动态库”“是否需要插件式扩展”“是否强调极致性能”等因素，推荐使用虚函数、模板、类型擦除（如 `std::function`、手写 type-erasure 类）等不同方案。

---

## 附录：如何“看见”对象模型

最后，我们会补充一些实践向的短文，帮助你把抽象概念落到具象的调试与观测手段上：

- [ ] **用编译器和调试器观察对象布局** (🚧 计划中)
    - 介绍如何通过 `sizeof`、`alignof`、调试器内存窗口、`objdump` / Compiler Explorer 等工具，验证本专栏中的对象布局心智模型。

- [ ] **常见未定义行为与对象模型：悬空引用、未初始化对象等** (🚧 计划中)
    - 列举几类与对象模型强相关的 undefined behavior，说明它们在内存层面到底踩了哪些红线，并给出在代码评审中如何快速识别这些问题的实用建议。

---

> **读完本专栏后**，你应该能：
>
> - 画出 C++ 对象的大致内存布局心智图，而不必死记 ABI 细节；
> - 清楚地知道什么时候该用继承与虚函数，什么时候应优先考虑组合或模板；
> - 在团队代码评审中，用“对象模型”的语言讨论接口设计，而不仅仅是语法对错；
> - 在需要时，能够借助编译器与调试工具“看见”对象模型，从而更有底气地做出接口与架构决策。
