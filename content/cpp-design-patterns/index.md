---
title: "C++ 设计模式专栏"
description: "面向实际工程的设计模式专栏：聚焦现代 C++ 写法与常见痛点场景。"
---

## 为什么还要谈设计模式？

即使你从来没有系统学过 GoF 23 种设计模式，只要写过几年 C++，你多半已经在不自觉地"用模式"了。区别只在于：你是凭经验写出来的，还是有一套可以交流、可以推导、可以改进的"明规则"。

本专栏站在**现代 C++（C++11 起步）**的视角，系统讲解经典设计模式。我们会覆盖全部 23 种模式，但**按实战痛点而非传统分类**来组织内容，优先讲解工程中最常遇到的场景。

> 与其背定义，不如先记住：它解决了什么具体的痛点。

## 专栏结构

### 第一阶段：告别 if-else 地狱

当你发现代码里的 `if-else` 或 `switch` 越来越长，每次新增类型都要改好几处，就该考虑这两个模式了。

- [ ] **策略模式 (Strategy)** (🚧 计划中)
    - 用多态替代分支、std::function 与 Lambda 的现代写法
- [ ] **状态模式 (State)** (🚧 计划中)
    - 有限状态机、与策略模式的区别

### 第二阶段：事件与通知

"一个事件发生了，谁该知道？" 这是 GUI、网络、业务流程中最常见的问题。

- [ ] **观察者模式 (Observer)** (🚧 计划中)
    - 发布-订阅、信号槽机制、弱引用避免内存泄漏
- [ ] **命令模式 (Command)** (🚧 计划中)
    - 撤销/重做、宏命令、任务队列
- [ ] **责任链模式 (Chain of Responsibility)** (🚧 计划中)
    - 中间件、事件冒泡、请求过滤

### 第三阶段：对象创建与资源管理

"对象从哪里来？谁负责它的生命周期？" 这是 C++ 区别于其他语言的核心问题。

- [ ] **单例模式 (Singleton)** (🚧 计划中)
    - Meyer's Singleton、线程安全、何时该用/不该用
- [ ] **工厂模式 (Factory)** (🚧 计划中)
    - 简单工厂、工厂方法、抽象工厂的选择
- [ ] **建造者模式 (Builder)** (🚧 计划中)
    - 链式调用、复杂对象的分步构造
- [ ] **RAII 与依赖注入** (🚧 计划中)
    - 智能指针、ScopeGuard、测试友好的设计

### 第四阶段：结构组织

当系统变大，如何组织类之间的关系？

- [ ] **适配器模式 (Adapter)** (🚧 计划中)
    - 接口转换、STL 中的适配器
- [ ] **装饰器模式 (Decorator)** (🚧 计划中)
    - 动态扩展功能、与继承的对比
- [ ] **代理模式 (Proxy)** (🚧 计划中)
    - 智能指针即代理、延迟加载、访问控制
- [ ] **组合模式 (Composite)** (🚧 计划中)
    - 树形结构、文件系统与 UI 控件
- [ ] **外观模式 (Facade)** (🚧 计划中)
    - 简化复杂子系统、API 设计

### 第五阶段：现代 C++ 惯用法

这些不是传统设计模式，但在现代 C++ 中同样重要。

- [ ] **模板方法与 NVI** (🚧 计划中)
    - 算法骨架、Non-Virtual Interface 惯用法
- [ ] **类型擦除 (Type Erasure)** (🚧 计划中)
    - std::function、std::any 的实现原理
- [ ] **CRTP：编译期多态** (🚧 计划中)
    - 静态多态、Mixin 类、性能优化

---
*注：标记为 🚧 的内容将陆续更新。本专栏基于 C++11 及以上标准。*
