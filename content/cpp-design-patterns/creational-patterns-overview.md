---
title: "创建型模式总览：从满地 new 到对象生产线"
description: "把单例、简单工厂、工厂方法、抽象工厂、Builder、原型串成一条演化故事线，聊聊它们背后的痛点与取舍。"
order: 5
---

如果你在 C++ 项目里熬过几个版本迭代，大概率经历过这样一条心路：

- 刚上手那会儿：哪里缺对象就地 `new`，用完顺手 `delete`，能跑就行；
- 写久了发现坑有点多，开始在代码里到处塞单例、搞几个“万能工厂”；
- 再后来，被线上事故和重构折腾了几轮，才慢慢意识到：
- **“对象怎么出生、谁来拍板、谁负责善后”这件事，本身就是架构级别的问题。**

GoF 那本蓝皮书刚火的时候，24 个模式被奉为神明，C++ 圈子里一度流行一句半开玩笑的话：

> 不会用设计模式，不好意思说自己是做面向对象的。

结果现实给了大家一堆耳光：

- 有团队到处上单例，最后搞出一堆“上帝对象”；
- 有人兴致勃勃画 UML，画完发现落地代码谁也看不懂；
- 也有人看完书一拍大腿：“原来我老早就在用这些东西，只是没给它们起过名字”。

这篇文章想做的事很简单：

- 不画 UML；
- 不按教科书顺序背定义；
- 就从一个老程序员的视角，
- **把 C++ 里的这几位创建型角色——单例、几种工厂、Builder、原型——串成一条时间线，顺手横向对比一下它们到底在解决什么。**

你可以把它当成是整个“创建型小系列”的**串场主持人**：

- 看完这一篇，再去读后面那几篇专门拆解某一个模式的文章；
- 或者在踩坑之后回过头来，对照一下：
- “当年要是早点用对这几个工具，是不是能少熬几个夜班？”

---

### 1. 从满地 `new` 和全局变量开始

先把时间拨回到还没有“模式热”的年代：

- C 时代，大家习惯的是 `malloc/free`；
- 早期 C++，只是把 `malloc` 换成了 `new`，顺手加了构造/析构；
- 稍微大一点的项目里，
  - 日志是一个全局对象，
  - 配置是一个全局对象，
  - 线程池、连接池、监控上报……能丢全局的全丢全局。

刚写的时候，味道其实挺香：

- 哪里想打 log 就 `g_logger.info(...)`；
- 哪里想查配置就 `g_config.get(...)`；
- 谁也不用费劲传依赖，看起来“一片清爽”。

等系统长到几十个翻译单元，上百个模块，你就会开始熟悉另一种场景：

- 某个全局对象在 A.cpp 里构造，又在 B.cpp 里用上；
- 初始化顺序完全说不清，
- 只要一碰“构造里用另一个全局”，就开始抽签；
- 关机时析构顺序乱飞，
- 加上多线程，整条调用栈都带着一点“未定义行为”的气质。

再叠加上“到处乱 `new`”这套：

- 谁需要对象是谁的构造函数就 `new` 一下；
- 不同模块各写一遍构造参数；
- 想换个实现、改个构造签名，要把全仓库的 `new Xxx` 翻一遍。

这就是创建型模式登场之前的底色：

> **大家隐约觉得“创建这块有味儿”，
>  但还没形成一个能讨论、能推导的共识。**

于是，单例、各种工厂、Builder、原型，就在这种“既想偷懒又想不出事”的氛围里，陆陆续续被发明出来——先是被总结进 GoF，那本书又反过来影响了一整代 C++ 项目。

---

### 2. 单例：给全局变量穿西装，但别当成正装天天穿

在很多团队眼里，**单例是第一个真正被喊出名字的“创建型模式”**。

它解决的问题，说白了就三件事捆在一起：

1. **概念上只要一份**：日志后端、配置快照、监控上报管道这类东西，放多份纯属找事；
2. **所有人都能找到入口**：你总得有个地方能轻易拿到它；
3. **生命周期很长**：从进程启动活到结束，谁也不想每次用之前再 `new` 一遍。

早年的写法五花八门：

- 有直接丢全局对象的：`Logger g_logger;`；
- 有靠静态成员 + `getInstance()` 的教材版；
- 多线程一来，大家又开始手搓 Double-Checked Locking，`pthread_once`，各种玄学写法齐飞。

C++11 做了一件小而关键的事：

> **规定函数内部局部 `static` 的初始化是线程安全的。**

从那之后，所谓 *Meyers Singleton* 终于可以不带心理阴影地写出来：

```cpp
static Logger& instance() {
    static Logger inst; // C++11 起，线程安全的局部 static
    return inst;
}
```

它确实比裸奔的全局变量体面：

- 避开了跨翻译单元的初始化顺序之坑；
- 语义清晰：这个类型“就打算全局一份”；
- 访问统一：谁用都走 `Logger::instance()`。

问题在于——**它太好写了。**

- 新人嫌传参数麻烦，顺手搞个单例；
- 老项目里有人图省事，把一堆无关逻辑塞进一个 `GlobalContext` 单例；
- 测试时想换实现，发现所有模块都在背后偷摸 `::instance()`。

多年下来，经验大致是这样：

- 真正像“进程级基础设施”的东西（日志后端、崩溃捕获框架）做成单例还算说得过去；
- 但**一旦它开始长成“上帝对象”或者简易 Service Locator，重构成本就会迅速飙升**；
- 更现代的做法，是把“唯一性”“访问方式”“生命周期”拆开，用 RAII + 依赖注入来组合，而不是一股脑塞进单例。

所以，单例更像是历史的起点：

> 从“完全不管全局状态”到“至少给全局状态一个门面”，
> 后面几位创建型兄弟，都是在帮我们把这件事拆得更清楚。 

---

### 3. 从一个大工厂，到一排小工厂，再到“一整套家居套餐”

当大家对“乱飞的 `new`”逐渐产生过敏反应时，**工厂一族上场了**。

#### 3.1 简单工厂：先把 `new` 收拢到一个地方

典型故事是这样的：

- 业务里到处有类似：
  - `if (type == image) new ImageTask(...);`；
  - `else if (type == video) new VideoTask(...);`；
- 每加一个类型，这坨 `if-else` 就胖一圈；
- 构造函数一变，你要在全仓库找一遍所有 `new Xxx`。

某天 code review 上，总会有人发出那句灵魂拷问：

> 能不能把这些 `new` 收到一个地方，大家排队领对象？

于是“简单工厂”就顺势长出来了：

- 抽一个 `createTask(req)` 出来，里面集中写那坨 `if-else`；
- 业务代码只负责拿到一个 `std::unique_ptr<Task>` 调 `run()`；
- 至于到底 new 了谁，交给工厂去纠结。

这一步的收益非常直接：

- **创建逻辑从业务里剥离出来**；
- 变化收拢到了一个相对集中的地方；
- 也给后面更高级的工厂玩法铺了路。

但时间一长，问题也来了：

- 产品线越来越多，`create()` 变成 if-else 垃圾场；
- 线上 / 压测 / 本地调试要用不同实现，环境分支又加一层；
- 你会发现：

> 自己亲手造的“万能工厂”，
> 终于也变成了新的单点垃圾堆。

#### 3.2 工厂方法：让“这次怎么造”交给子类

第二阶段的反思大概是：

> 与其一个工厂知道所有场景，不如**每个场景有自己的小工厂**。

于是大家开始写：

- `struct TaskFactory { virtual std::unique_ptr<Task> create(const Request&) = 0; };`
- `ProdTaskFactory` 只关心线上环境的那一摊；
- `DevTaskFactory` 只关心本地 / 测试用的 mock；
- 业务代码只依赖 `TaskFactory&` 这个抽象，
  - 至于背后是哪个实现，由外层“注入”进来。

这就是**工厂方法**的味道：

- 那个可重写的 `create()`，就是“工厂方法”；
- “创建哪种具体产品”的决定权，从 if-else 挪到了虚函数多态上；
- 简单工厂垮塌成了一排更聚焦的小工厂。

你可以把它理解成：

> **简单工厂帮你把 `new` 收拢，
>  工厂方法帮你把已经长胖的简单工厂拆开养。**

#### 3.3 抽象工厂：一整套家居套餐一起换皮

等项目再大一点，你会发现另一类问题：

- 有些“产品”不是单独出现的，而是**成套出现的**；
- 换 UI 主题不仅要换 Button，还要换 TextBox / Menu / Dialog；
- 换数据库驱动，不只是换 Connection，还要成套换 Statement / ResultSet / Transaction。

如果还是一条条产品线各自有工厂：

- `ButtonFactory` 管 Button；
- `TextBoxFactory` 管 TextBox；
- `MenuFactory` 管 Menu；

你就很容易搞出“半套新皮肤 + 半套旧皮肤”的诡异界面——因为某个地方忘了把三家工厂一起换。

抽象工厂干的事情，是把这几条产品线打包：

- 抽出一个更大的 `ThemeFactory`：里面有 `createButton()` / `createTextBox()` / `createMenu()`；
- Light 主题有一个 `LightThemeFactory`，Dark 有一个 `DarkThemeFactory`；
- 业务代码只拿到一个 `ThemeFactory&`，成套拿控件，**保证“这一整页要么全是 Light，要么全是 Dark”**。

所以，从简单工厂走到工厂方法，再走到抽象工厂，其实是一条很自然的进化线：

1. **先收拢：** 从满地乱 `new` 到一个简单工厂；
2. **再拆分：** 简单工厂长胖后，用工厂方法按场景拆成多种工厂类型；
3. **最后打包：** 当“整套对象一起换皮”变成常态时，用抽象工厂把这整套产品族封成一个抽象入口。

---

### 4. Builder 和原型：当“怎么配好一个对象”本身值得被抽出来

很多人第一次接触创建型模式，只记得“有一堆工厂，再加一个单例”。

等写久了，就会发现：

- 有些对象本身就很复杂，
  - 构造函数参数一长串，
  - 配置 struct 里一堆 bool / 可选字段；
- 有些对象“配好一次特别费劲”，
  - 以后要经常“按这份配置再来一份，稍微改两下”。

这时候，**Builder 和原型就轮到他们上场了。**

#### 4.1 Builder：给复杂对象找个“装修队长”

想象一下那种经常在业务里见到的构造函数：

```cpp
Order(const std::string& userId,
      const std::string& productId,
      int quantity,
      bool needInvoice,
      bool allowSplit,
      bool useCoupon,
      bool isVipOnly,
      const std::string& remark,
      /* ... 还在继续长 ... */);
```

刚写出来的时候，大家还背得清第七个 `bool` 是干嘛的；

- 半年以后，只要有人复制一调用点、随手填了几个 true/false；
- 再过几个月，谁也不敢动，生怕改崩线上一长串逻辑。

Builder 关心的就是这类“**构造过程本身已经复杂到值得有个角色来管理**”的场景：

- 把构造拆成一系列有名字的小步骤：`setUser(...)` / `needInvoice()` / `allowSplit()` / ...；
- 用链式调用把这些步骤串起来，看起来更像一串 DSL：

  ```cpp
  auto order = OrderBuilder{}
      .user("u123")
      .product("p456")
      .needInvoice(true)
      .useCoupon(false)
      .build();
  ```

- 把“哪些组合是合法的”“哪些字段必填”集中放到 `build()` 里检查；
- 最后产出的对象往往是**构造完就基本不可变**的，生命周期干干净净。

从工厂 / 抽象工厂的角度看：

> 它们解决的是“这一回我要哪一类对象”；
>
> Builder 解决的是“**这一类对象本身，是怎么一步步被装配出来的**”。

#### 4.2 原型：按“样板房”复制对象

另一位常被忽视的创建型选手是 **原型模式 (Prototype)**。

典型剧情：

- 系统启动阶段，先准备好若干“样板对象”，
  - 比如各种默认套餐、计费策略、怪物模板；
- 运行时要新建实例时，
  - 并不是从零开始配，
  - 而是**先复制样板，再改几个关键字段**。

在 C++ 里，这经常长成基类上的一个 `virtual clone()`：

- `Shape` 定义 `virtual std::unique_ptr<Shape> clone() const = 0;`；
- `Circle` / `Rectangle` 分别在里面用拷贝构造把自己复制一份；
- 上层只拿着一个 `Shape*`，在**不知道具体派生类是谁**的前提下，就能复制出一份一模一样的新对象。

再往上一层，你通常会再加一个“原型注册表”：

- 按名字把一堆样板对象挂进去；
- 以后通过 `registry.create("big_circle")` 这种方式按名拿副本；
- 调用方既不用反复写初始化细节，也不用操心对象切片、多态拷贝这些 C++ 的坑。

如果用“房子”来打比方：

- **工厂 / 抽象工厂**：你在售楼处选“哪一种户型 / 哪一套家居套餐”，开发商照着图纸再造一套给你；
- **Builder**：你和装修队长从毛坯房一步步选材、装灯、贴砖，整个装修过程本身被抽象出来；
- **原型**：你逛了一圈样板房之后，说“就按这套来一套，地板颜色浅一点就行”，开发商按样板房复制一份给你。

这三位经常是一起配合的：

- 用工厂挑“第一次造哪一类东西”；
- 用 Builder 把第一次那套复杂构建写清楚；
- 再用 Prototype + 注册表，在运行期不断“按样板来一份，再小改一下”。

---

### 5. 横向看：写 C++ 时，创建对象前可以先问自己的几句话

如果只背模式名字，很容易在脑子里成一团。更实用的做法，是在准备敲下一个 `new` 之前，先在脑子里过一遍下面几句：

1. **这东西在概念上，需要多少份？**
   - 真的全局唯一？还是“这一条请求链路里大家共用一份”就够？
   - 如果只是“传起来麻烦”，往往说明你更需要依赖注入，而不是单例。

2. **谁来拍板“这次要造哪一类对象”？**
   - 是业务代码自己到处 `if (type == ...) new Xxx`？
   - 还是收拢到一个简单工厂？
   - 再或者，干脆交给不同场景各自的工厂子类？

3. **构造过程本身是不是复杂到值得单独抽出来？**
   - 如果只是两三个参数的小 struct，没必要为了“用上 Builder”硬设计；
   - 如果已经出现“参数墙 + 配置对象乱飞”，Builder 往往能把构造逻辑从业务里剥离出来。

4. **未来会不会频繁“按样板复制，再小改”？**
   - 如果会，而且这些样板本身还是多态层次里的成员；
   - 那么在基类上约一个 `clone()`，配合原型注册表，往往要比硬写一串 `switch(type)` 更稳、更好演进。

把这些问题和前面几篇文章里的比喻——“给全局变量穿西装”“简单工厂前台窗口”“一整套家居套餐”“装修队长”“样板房”——连在一起，你会发现：

> 创建型模式并不是要你背多少图，
> 而是帮你把“创建对象”这件事拆成几根清晰的思考轴。 

---

### 6. 现代 C++ 视角：当模式“长进了语言和库”里

再往后看，到了 C++11 之后，故事又有了一个有趣的转折。

- `std::unique_ptr` / `std::shared_ptr` + `std::make_unique`，
  - 把“谁负责销毁”这件事塞进了 RAII；
- `std::function` / `std::any` / 各种类型擦除技巧，
  - 把一部分“策略选择”藏进了库里；
- 各种 IoC / DI 框架、配置驱动工厂，
  - 让你可以在不改代码的情况下切换实现。

很多人会感觉：

> 设计模式好像“过气”了，
> 因为看不到那么多显式的工厂类和单例了。

但如果你拆开这些现代库和框架，会发现：

- **创建型模式并没有消失，
  只是悄悄长进了语言特性和框架约定里。**

- 局部 `static` + RAII，是在帮单例善后；
- `std::make_unique` 背后隐藏着一小块“简单工厂”的味道；
- 各种 DI 容器本质上就是大型抽象工厂 + 注册表；
- Builder 风格的链式 API，已经成了现代 C++ 库的家常便饭。

从某种意义上说：

> GoF 那代人用“模式”给了我们一套语言，
> 后来的标准和库，把其中一部分直接铸进了语法和 API 里。

你不一定非要在代码里写一个类叫 `XxxFactory`，才算用了工厂；

- 关键在于你脑子里有没有那几根轴：
  - 谁拍板？
  - 在哪一层拍板？
  - 生命周期谁兜底？
  - 以后要怎么演进？

---

### 7. 给新手和老手的几个小提醒

**对刚入行的同学：**

- 别急着记定义，先多对照自己项目里的实际场景；
- 每次见到“到处乱 `new` / 全局变量 / 上帝单例”，
  - 都可以拿这几种创建型模式对照着想一想：
  - “要是用上某个模式，会不会稍微干净一点？”
- 真正有用的是那种“写完能在 code review 上说清楚自己在干嘛”的设计，
  - 不是什么“强行凑够 23 种模式”。

**对已经被线上 bug 打磨过的老程序员：**

- 很多你本能就会的做法，其实已经踩在这些模式的路线上了；
- 把它们串成一条时间线，
  - 有助于你在和新人讲解、和同事争论时，
  - 少一点“拍大腿式的经验”，多一点可复用的语言；
- 也方便你在重构老代码时，
  - 把“当年乱飞的 `new` 和全局状态”，
  - 慢慢拆回到“更清晰的创建决策 + 更可控的生命周期”上。

最后留一个小练习给你：

> 下次你在项目里准备新开一块“造对象”的逻辑时，
> 在注释里先写一句：
>
> - 我打算用哪一种创建思路？
> - 它主要是在解决哪个痛点？
>
> 等几个月之后你（或者别的同事）再回来看这段代码，
> 会发现这句注释比一整张 UML 图都更有价值。