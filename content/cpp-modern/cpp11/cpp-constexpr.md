---
title: 'constexpr 与常量表达式：把“能算的”提前算掉'
description: '从宏、enum 伪常量、模板元编程的“黑魔法”，一路讲到 C++11 的 constexpr：让能在编译期算出来的东西，别拖到运行时。'
---

我第一次真正在意“常量”。

不是因为它难。

是因为它太容易被写错。

然后还很难查。

那会儿我在修一个老项目。

头文件里全是 `#define`。

像家谱。

谁也不敢动。

但线上就是这么爱挑这种时候出事。

某次夜里。

报警响了。

日志里只有一句。

“buffer overflow”。

你问我当时第一反应是什么。

不是查指针。

是去翻那一排宏。

因为我太熟悉这种套路了。

“反正是常量嘛。”

这句话听起来很稳。

但它经常意味着。

“我们没让编译器替我们看住它。”

先给你看一个当年最常见的坑。

```cpp
#define SQUARE(x) x * x
```

看着很朴素。

然后有人这样用。

```cpp
int v = SQUARE(a + b);
```

你以为它在算 `(a + b) * (a + b)`。

它其实在算 `a + b * a + b`。

宏不讲理。

它只会把字展开。

那天我才意识到一件事。

我们需要的不是“看起来不变”。

我们需要的是。

能被语言检查的“不变”。

后来 C++11 给了一个更像语言的答案。

`constexpr`。

我一直觉得它像委员会写给工程师的一句道歉。

“以前你们只能靠歪招。”

“现在给你们一条正路。”

# 在 constexpr 之前：大家都怎么凑合

C/C++ 很长一段时间里，编译期的表达能力不够用。

但工程又逼着你必须“提前算”。

于是大家就各显神通。

### 宏：最快，但最不讲武德

宏能做的事，说白了就是文本替换。

你要的其实是“单位”。

宏给你的只是“展开”。

```cpp
#define KB(x) ((x) * 1024)
```

它没有类型，也没有作用域，更不会替你检查什么。

你写错了，它只会很努力地把错扩散到全工程。

### enum 伪常量：老派，但挺实用

后来大家学聪明了。

既然宏不可靠，那就用语言本身。

```cpp
enum { BufferSize = 4096 };
```

它看起来像常量，也确实是编译期常量，而且有作用域（至少比宏强）。

但它也很“别扭”。

你只是想写一个常量，却得借用枚举的语法。

有点像你只是想钉个钉子，结果得先学会开挖掘机。

### const：你以为稳了，其实还不够

很多人会写。

```cpp
const int N = 10;
```

在很多场景下，这确实能当常量。

但 `const` 的核心语义是“只读”，不是“编译期”。

你很快就会遇到这种。

```cpp
int read();
const int N = read();
```

它当然是只读的，但它不是常量表达式。

你别指望它能去当数组长度，也别指望它能去当模板参数。

工程里最烦的就是这种。

你以为你写的是“常量”。

结果它只是“运行时的只读变量”。

### 模板元编程：硬算出来的编译期

再后来，高手们开始用模板做计算。

不是因为他们喜欢折磨自己。

是因为没得选。

```cpp
template <int N>
struct Factorial {
    static const int value = N * Factorial<N - 1>::value;
};

template <>
struct Factorial<0> {
    static const int value = 1;
};
```

你看懂了，说明你已经在 C++ 里混过一阵。

你看不懂，也没关系。

这玩意儿的可读性本来就不打算照顾普通人。

但它确实能在编译期算。

也确实能塞进模板参数里。

那时候的工程经验就是。

“能不用就别用。”

“真要用，也别让新人维护。”


# C++11 的 constexpr：终于像个人话了
 
`constexpr` 做了一件很朴素的事：它把“能在编译期求值”变成语言层面的承诺。
你可以写一个函数，让它在需要的时候变成编译期计算；不需要的时候，它也能当普通函数跑。

这点很重要。
工程里从来不是“全编译期”。
更多是“能提前就提前”。

### 先来个经典：编译期的阶乘
 
```cpp
constexpr int factorial(int n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
}
```

注意这句：它长得像普通递归，但它多了 `constexpr`。

这就等于你跟编译器说：如果参数是常量表达式，你就给我在编译期算出来。

然后你可以把结果塞进需要编译期常量的地方。

```cpp
#include <array>

std::array<int, factorial(5)> a{};
```

这不是语法糖，而是一种工程上的“止损”。

数组长度、模板参数这些地方最怕运行时的暧昧。

要么是常量。

要么别来。

### 同一个函数，也可以在运行时用

有意思的点在这里：`constexpr` 函数不是只能编译期跑。

你把参数换成运行时值，它就老老实实地在运行时算。

```cpp
int f(int n) {
    return factorial(n);
}
```

这里的 `factorial(n)` 不会要求 `n` 必须是常量表达式。

编译器会做它能做的，做不到就算了。

这也是我喜欢 `constexpr` 的地方。

它不像某些“全 or 无”的设计，它更像一个现实主义的工程工具。

# 常量表达式到底是什么

“常量表达式”听起来像学术，但你先别怕。

你可以把它理解成一句人话：编译器能不能在编译的时候，把这个值算死。

这里的“编译的时候”，就是程序还没跑起来，编译器还在把源码变成可执行文件。

相对的，“运行时”就是程序真的跑起来之后，开始吃输入、读文件、收网络包。

能在编译时算死，它就能出现在一些很苛刻的位置。

比如数组大小、模板参数、`case` 标签。

常量表达式，说到底就是“能不能提前算”。

### `const` 和 `constexpr`，差的不是一个字母

写久了你会发现：`const` 解决的是“能不能改”，`constexpr` 更在乎“能不能提前算”。

`const` 管的是写保护。

`constexpr` 管的是“能不能当场算出来”。

```cpp
const int a = 10;
constexpr int b = 10;
```

这两行看起来差不多，但 `b` 的语义更硬。

它要求初始化值本身就是常量表达式。

```cpp
int read();

// constexpr int x = read(); // 这句别指望能过
```

这种“硬”，在工程里是好事。

它会逼你把边界说清楚：到底是常量，还是只是不会改。

# 场景：你真的会用到它

很多人第一次听 `constexpr`，会把它理解成“优化”。

我更愿意把它当成“提前验收”。

你把一些条件写死在代码里，编译器替你盯着。

一旦有人乱改，它就在编译期把你拦下来。

说白了，就是把一些线上才会爆的坑挪到编译时就爆。

编译期炸一下，比半夜醒一次划算。

### 场景零：线上啪一下（一个取模的小聪明）

我见过最“可惜”的线上事故，不是指针乱飞。
是一个常量被人顺手改了一下，然后整个服务开始间歇性丢数据。

当时我们写了个很小的环形队列，为了省事我用了一个老技巧：用按位与 `&` 来代替取模 `%`。
它确实更快，但它有前提：缓冲区大小必须是 2 的幂。

问题就出在这里：大家只记住了“更快”，忘了“有前提”。

先把事故复现给你看。

```cpp
#include <cstddef>

constexpr std::size_t kBufSize = 1000; // 有人为了省一点内存，改成了 1000
constexpr std::size_t kMask = kBufSize - 1;
std::size_t wrap(std::size_t i) {
    return i & kMask; // 只有 kBufSize 是 2 的幂时，这才等价于 i % kBufSize
}
```

这段代码在你本机跑几次，你可能还真看不出毛病。
线上一压，写指针绕回来的位置就开始“飘”。
数据像被鬼拿走。

这种时候，我最想要的不是更快，是更早炸。
在编译期就炸。

```cpp
#include <cstddef>

constexpr std::size_t kBufSize = 1024;
static_assert((kBufSize & (kBufSize - 1)) == 0, "kBufSize must be power of two");
constexpr std::size_t kMask = kBufSize - 1;
std::size_t wrap(std::size_t i) {
    return i & kMask;
}
```

这句 `static_assert` 的作用也很简单：确保 `kBufSize` 是 2 的幂，不满足就让编译直接失败。

“你要是敢把它改成 1000，编译就别想过。”

### 场景一：协议、文件格式、魔数

做协议解析的时候，你会遇到很多固定值（魔数）。
你希望它们是编译期常量，因为这些值本来就不该变。

```cpp
#include <cstdint>

constexpr std::uint32_t kMagic = 0xDEADBEEF;
```

这行代码的好处不是它更快，是它更不容易被人改坏。
而且你能拿它去做编译期检查。

```cpp
static_assert(kMagic != 0, "");
```

我知道这个断言看起来有点傻。
但在大工程里，这种“傻”经常救命。

### 场景二：用 `std::array` 做静态表

有些表就是固定的，比如某些字符分类，比如查表加速的权重。
如果你用 `std::vector`，它通常是运行时构造，你还要考虑初始化顺序和动态分配。

有时候你就是不想要这些戏。

```cpp
#include <array>

constexpr std::array<int, 4> kDx{1, 0, -1, 0};
constexpr std::array<int, 4> kDy{0, 1, 0, -1};
```

它们像常量，也真的是常量。
而且没有动态分配，也没有初始化顺序地雷。

### 场景三：让类型也能“提前活起来”

`constexpr` 不只是给数字用。
它也可以给类型的构造用。

```cpp
struct Point {
    int x;
    int y;

    constexpr Point(int x, int y) : x(x), y(y) {}
};

constexpr Point origin{0, 0};
```

对象也能是编译期常量。
这在写数学库、写几何、写编译期配置的时候很顺手。

它让“常量”不再只是一堆裸数字，而是带语义的对象。

# 一点现实：C++11 的 constexpr 其实很克制

很多人今天看 `constexpr`，会觉得它“能写循环”“能写复杂逻辑”。
但那是后来的事。

C++11 刚引入它的时候要求很严格，你基本只能写一个很“纯”的函数，更像数学表达式。
所以你会看到一堆递归：不是因为大家都爱递归，是因为当时的 `constexpr` 就允许你这么写。

再往后 C++14 放宽了限制，C++20 又来了 `consteval`，把“必须编译期”这件事说得更死。
但这些都是后话。

你先把 C++11 的这个口子打开。
工程就已经能少掉一批祖传技巧。

# 结尾：constexpr 的真正价值

我用 `constexpr` 用得越久，越不把它当成“性能技巧”。

它当然可能更快，但这不是我最在意的。

我最在意的是，它让你把边界写进代码里：哪些值天生不该变，哪些前提必须满足。

你把这些交给编译器看着，比交给夜班同事记着靠谱。

很多线上事故不是算法错。

是一个“常量”被人顺手改了一下。

`constexpr` 加上 `static_assert`，像在代码里贴了封条。

谁撕，谁当场被拦下来。

`constexpr` 的价值不是“提前算”。

是“提前出错”。
