---
title: 'C++11 内存模型与 atomic：你以为的“顺序”，可能不存在'
description: 'C++11 把并发里最危险的部分写进标准：数据竞争是未定义行为，atomic + memory order 让你能和编译器、CPU 讲清楚“顺序”。'
---

并发里最吓人的东西。

不是 `std::thread`。

也不是锁。

是你刚从 C with classes 走过来时。

脑子里那句很自然的话。

“我先写 data。”

“再写 ready。”

“别人看到 ready 了。”

“那就一定也能看到 data。”

单线程里。

这句话几乎永远成立。

多线程里。

它经常把你坑到怀疑人生。

我见过最典型的场景。

一个线程准备数据。

另一个线程等一个标志位。

标志位一亮就去读数据。

```cpp
bool ready = false;
int data = 0;

// thread A
data = 42;
ready = true;

// thread B
if (ready) {
    use(data);
}
```

你脑子里会自动补一句。

ready 都 true 了。

data 肯定已经是 42。

但在多线程里。

“看到 ready” 和 “看到 data”。

是两件事。

它们甚至可能发生在不同时间。

原因你不需要懂指令。

只需要接受一个现实。

编译器和硬件为了快。

会在不改变单线程结果的前提下。

调整一些读写的顺序。

而不同线程之间。

如果你没有明确的同步。

标准就不会替你保证“可见性”。

C++11 的内存模型。

是委员会对这个世界的一次正面承认。

> 多线程不是“把代码跑快”。
>
> 多线程是“你得跟硬件讲道理”。

## 数据竞争：不只是 bug，是未定义行为

C++11 明确规定。

如果两个线程。

在没有同步的情况下。

同时访问同一个对象。

其中至少一个是写。

那就是 data race。

结果是未定义行为。

不是“有时错”。

是“标准不保证任何事”。

这句话很冷。

但它的好处是。

它把边界画出来了。

你以后遇到并发问题。

先别急着背 memory order。

先问自己一句。

“这里有没有数据竞争？”

如果有。

先用最朴素的办法消掉它。

mutex。

condition_variable。

这些工具不性感。

但它们最像新手需要的安全带。

你不需要猜。

也不需要赌。

## atomic：把共享变量升级成“有协议的共享”

但有些场景。

你确实只想共享一个很小的东西。

一个标志位。

一个计数器。

这时候 atomic 很合适。

它的核心不是“更快”。

是“更有规矩”。

你把 `ready` 变成 atomic。

你就从“赌运气”变成“按协议交接”。

先给一个你能直接照抄的版本。

不用想太多。

先用默认顺序。

```cpp
#include <atomic>

std::atomic<bool> ready{false};
std::atomic<int> data{0};

// thread A
data.store(42);
ready.store(true);

// thread B
if (ready.load()) {
    use(data.load());
}
```

这段代码的“人话版协议”是。

thread A 先把数据写好。

再把 ready 举起来。

thread B 看到 ready。

再去读 data。

你不用理解 CPU。

也不用理解汇编。

你只需要记住。

atomic 变量之间。

有标准承诺的同步语义。

如果你以后开始在意性能。

或者你想用一个 atomic 标志位去“发布”一份普通数据。

你会遇到 `release/acquire`。

它听起来抽象。

但可以用一句更生活的话记。

> release 像“盖章发布”。
>
> acquire 像“验章接收”。

发布之前写的东西。

接收之后就能看见。

它追求的不是“严格的执行顺序”。

而是“可见性保证”。

## memory_order：你到底要多强的保证

C++11 给了几种 memory order。

你不需要背全。

但你得知道它们的性格。

`relaxed`：只保证原子性，不保证顺序。

`release/acquire`：建立一个单向的“先后关系”。

`seq_cst`：最强，最像你脑子里的直觉顺序。

很多人一开始就用默认的最强保证。

没毛病。

先写对。

再写快。

但你也要知道。

越强的约束。

越可能牺牲性能。

越可能阻碍编译器优化。

## 一个很常见的误区

atomic 不是万能锁。

你把所有变量都改成 atomic。

并不等于程序就正确。

因为正确性往往是“跨多个变量的协议”。

比如。

一个队列。

一个状态机。

一个对象的生命周期。

这些东西单靠 atomic 很难写对。

你通常需要更高层的同步原语。

mutex。

condition_variable。

或者更成熟的并发数据结构。

## 小洞见

C++11 内存模型最有价值的地方。

不是让你每天手写 memory order。

而是让“并发正确性”变成可讨论的东西。

以前你只能说。

“我觉得应该没问题”。

现在你可以说。

“这里是 release/acquire”。

“这里不存在 data race”。

你能用标准语言跟团队沟通。

也能跟编译器沟通。

这才是 C++11 真正的进步。
