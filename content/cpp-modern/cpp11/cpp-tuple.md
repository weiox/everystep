---
title: 'std::tuple：多返回值与结构化打包（无宏版）'
description: 'C++11 的 tuple 让“返回多个值”不再依赖 out 参数或 struct 临时拼装，也成为很多泛型库的基础积木。'
---

C++ 老代码里。

多返回值通常有两种姿势。

一种是 out 参数。

一种是自己写个 struct。

out 参数很直白。

但读起来像在办手续。

```cpp
bool parse(const std::string& s, int& a, int& b);
```

你得先准备两个变量。

再把它们交进去。

struct 更干净。

但你得专门定义一个类型。

哪怕它只用一次。

C++11 给了 `std::tuple`。

它更像一个“类型安全的打包盒”。

## 最常见的用法：打包返回

```cpp
#include <tuple>

std::tuple<int, int> parse2();

auto t = parse2();
int a = std::get<0>(t);
int b = std::get<1>(t);
```

这写法不算优雅。

但它很正规。

类型在 tuple 里。

顺序也在 tuple 里。

你至少不再靠指针和引用传递。

## tuple 在泛型代码里更像“基础设施”

你会在很多地方遇到它。

比如把参数包变成一个对象。

比如把一堆东西一起转发。

比如元组上的 apply。

这些东西看起来像库作者的玩具。

但它们的共同点是。

把“多个东西”当成一个值。

这让组合变得可能。

## 小洞见

如果只是业务代码。

很多时候一个小 struct 更好读。

tuple 适合两类地方。

一类是你真的只想临时打包。

一类是你在写泛型库。

需要一个“通用容器”来承载类型序列。

它不是为了替代结构体。

它是为了让类型系统有一个能装下“多个”的盒子。
