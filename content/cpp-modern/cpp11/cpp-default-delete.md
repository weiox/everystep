---
title: '= default 和 = delete：驯服编译器的「小脾气」'
description: '还在为编译器神出鬼没的默认函数而烦恼吗？学会 C++11 的 = default 和 = delete，像使唤「小精灵」一样精确控制类的特殊成员函数！'
order: 1
---

你可能遇到过这样的经历：一开始写了一个很朴素的结构体，创建对象、拷贝对象都好好的。后来想着“我要认真一点”，给它加了一个构造函数，结果编译器忽然开始报错，说什么“没有匹配的构造函数”“对象不能默认构造”之类的。

明明只是多写了一个函数，程序为什么就不高兴了？

很多时候，这不是你写错了，而是你和编译器之间“沟通不充分”。在 C 风格的思维里，我们习惯自己掌控一切；到了 C with class 时代，编译器又悄悄替我们做了很多事；到了 C++11，又多了 `= default` 和 `= delete` 这样的新语法，让你可以更明确地告诉编译器“这件事你继续帮我做”“那件事你千万别做”。

这篇文章要讲的，就是这两句看起来不起眼的小短语，背后到底控制着什么。

### 一个看似无辜的改动：为什么多了一个构造函数就编译失败？

先从一个非常普通的二维点开始。假设你只写了一个最简单的结构体：

```cpp
struct Point {
    int x;
    int y;
};

int main() {
    Point p1;      // 默认构造：x 和 y 的值是未初始化的
    Point p2{1, 2}; // 聚合初始化：x = 1, y = 2
}
```

到目前为止一切正常。`Point` 只是两个 `int` 叠在一起，编译器很开心，它会自动帮你生成“从无到有”的那一步，也就是所谓的“默认构造函数”。

某一天你觉得这样不太安全，决定强制每个点都要有明确的坐标，于是给它加了一个带参数的构造函数：

```cpp
struct Point {
    int x;
    int y;

    Point(int x_, int y_) {
        x = x_;
        y = y_;
    }
};
```

现在你写下面这段代码：

```cpp
int main() {
    Point p1(0, 0);  // 有参构造：没问题
    Point p2;        // 想当然地以为还能这么写
}
```

编译器这时会告诉你：`Point` 没有默认构造函数，`Point p2;` 这句不合法。

这就是第一个容易让人摸不着头脑的问题：以前什么也不写的时候，明明是可以默认构造的，为什么我“更认真”地写了一个构造函数之后，默认构造反而不见了？

原因是：只要你自己声明了任何一个构造函数（哪怕只是一个带参数的），编译器就会认为“关于怎么构造对象，你已经自己接手了”，于是它不再自动为你生成无参数的那个版本。它不会替你猜“你是不是还想要一个默认构造”。

如果你既想保留带参数的构造，又想要一个最普通的默认构造，在 C++98 的时代，你只能自己再写一个：

```cpp
struct Point {
    int x;
    int y;

    Point() {}                 // 手写一个“什么也不做”的默认构造
    Point(int x_, int y_) {    // 再写一个带参数的
        x = x_;
        y = y_;
    }
};
```

这看起来有点多余。你本来就想要编译器那一套最普通的默认行为，却不得不自己写一遍。类一旦变复杂，这样的“照抄”就变得既累人又容易出错。

C++11 的 `= default` 出场，就是为了解决这种“我只是想要你原来那一版”的尴尬。

### 编译器背后的那六位“隐形员工”

要理解 `= default` 和 `= delete` 在干什么，先得看清楚编译器平时悄悄帮你做了哪些事。

只要你写了一个类或结构体，哪怕里面什么也没有，编译器在心里都会给它配上一整套“生命周期相关的成员函数”。在 C with class 的世界里，这套东西是默认存在的，只是你经常没有显式地写出来。

最简单的例子：

```cpp
struct Widget {
    int value;
};
```

你只写了一个 `int` 成员，但是下面这些代码都可以通过编译：

```cpp
int main() {
    Widget a;          // 从无到有：默认构造
    Widget b = a;      // 从另一个对象“复制”构造
    b = a;             // 赋值：把 a 的内容拷贝给 b
}
```

之所以可以这么用，是因为编译器在背后帮你生成了几种特殊的成员函数。大致可以想象成：它给 `Widget` 分配了一个“管家”，负责：

1. 从无到有地创建一个对象（默认构造）。
2. 把一个现有对象“克隆”到新对象里（复制构造）。
3. 把一个现有对象的状态赋给另一个已有对象（复制赋值）。
4. 在对象生命周期结束时，做必要的清理（析构）。

在 C++11 之后，又多了一对“移动”相关的函数，用来支持高效地把资源从一个对象“挪到”另一个对象：

5. 用一个将亡的对象初始化新对象（移动构造）。
6. 用一个将亡对象给已有对象赋值（移动赋值）。

当你什么也不写时，编译器会为你自动生成一个“最朴素版本”的这六个函数。大多数情况下，这些自动生成的函数做的是“成员逐个拷贝”，也就是对每个成员都做一遍拷贝或移动操作。

从这里开始，只要你自己写了其中的一部分，编译器就会开始“揣摩你的用意”，有些它就不再帮你自动生成了，这就是你看到那些“神秘报错”的根源。

### 用 = default 明确地说：“这一项请按标准来”

回到刚才的 `Point`，我们已经看到，一旦你声明了一个带参数的构造函数，默认构造就不再自动生成了。如果你确实还需要默认构造，现在有比 C++98 更优雅的写法：

```cpp
struct Point {
    int x;
    int y;

    Point() = default;          // 请求编译器生成“标准默认构造”
    Point(int x_, int y_) {     // 自己定义一个带参数的构造
        x = x_;
        y = y_;
    }
};
```

这行 `Point() = default;` 的意思是：“这个默认构造函数请你照你平时的标准写法来生成，不要因为我写了别的构造函数就不给我了。”

这样做有两个好处。

第一，你不需要自己去写一个空实现，不会因为成员名字变了、成员顺序变了而漏改哪一处，省去了重复劳动。

第二，你的意图非常清晰。任何读这段代码的人，一眼就能看出你既想支持默认构造，又想支持带参数构造，而且默认构造用的就是编译器那一版。

`= default` 并不只可以用在默认构造上。对那六个“隐形员工”中的任何一个，你都可以用类似的方式说一句“请用你标准的写法生成”：

```cpp
class Buffer {
public:
    Buffer() = default;                          // 默认构造

    Buffer(const Buffer&) = default;             // 复制构造
    Buffer& operator=(const Buffer&) = default;  // 复制赋值

    Buffer(Buffer&&) = default;                  // 移动构造（C++11）
    Buffer& operator=(Buffer&&) = default;       // 移动赋值（C++11）

    ~Buffer() = default;                         // 析构函数
private:
    int size_ = 0;
};
```

你可以只为其中一部分写上 `= default`，比如只想明确说“我确实要支持复制”，又或者你写了别的构造函数，但仍然要一个默认构造。编译器会根据你写下的这些声明，来决定哪些函数需要它生成标准版本，哪些干脆不提供。

有时你甚至可以把 `= default` 写在类外面，让这个函数看起来更像是“用编译器的标准实现定义了一下”。例如：

```cpp
class Line {
public:
    Line();                     // 只声明，不写实现
private:
    int length_ = 0;
};

// 在类外面说：这个构造函数用默认实现
Line::Line() = default;
```

在一些依赖“平凡/非平凡”特性的场景下（比如做底层优化），“在类内 default” 和 “在类外 default” 还会有一些细微差别，但对刚从 C 和 C with class 过来的读者来说，先记住最重要的一点就够了：`= default` 是你主动告诉编译器“我确实要这个默认版本”。

### 有些对象可以复制，有些对象绝对不能复制

现在来看另一个更危险、但在 C with class 世界里非常常见的例子：一个类负责管理某个底层资源，比如文件句柄。

先写一个简单到不能再简单的 `File` 类，只负责“打开”和“关闭”一个 C 标准库里的 `FILE*`：

```cpp
#include <cstdio>

class File {
public:
    File(const char* filename, const char* mode) {
        handle_ = std::fopen(filename, mode);
    }

    ~File() {
        if (handle_) {
            std::fclose(handle_);
        }
    }

private:
    std::FILE* handle_ = nullptr;
};
```

这个类单独看起来没问题。你在函数里写：

```cpp
void write_something() {
    File f("data.txt", "w");
    // 在这里向文件里写数据……
}
```

函数结束时，`f` 的析构函数会自动帮你关闭文件，资源管理得很好。

问题出现在你不小心让这个类“可以被复制”的时候。比如有人写了这样的代码：

```cpp
void bad() {
    File f1("data.txt", "w");
    File f2 = f1;  // 看起来只是“复制一个文件对象”
}
```

你并没有为 `File` 写复制构造函数，但编译器会很热心地为你生成一个“逐成员拷贝”的版本。也就是说，它只是简单地把 `f1.handle_` 的值拷贝到 `f2.handle_` 中去，于是这两个对象内部指向了同一个 `FILE*`。

当 `bad` 结束时，`f2` 先析构，`fclose` 一次；然后 `f1` 再析构，再 `fclose` 一次。对同一个 `FILE*` 做两次 `fclose`，这是未定义行为，很容易直接让程序崩掉。

对这种“管理独占资源”的类来说，最安全的做法通常不是“实现一个复杂的深拷贝逻辑”，而是干脆禁止复制，也就是让它变成“只能有一个实例拥有这份资源”。

### C++98 的老办法：把复制函数藏到 private 里

在 C++11 之前，大家是这样禁止复制的：把复制构造函数和复制赋值运算符声明成 `private`，而且不去给它们写实现。

```cpp
class File {
public:
    File(const char* filename, const char* mode) {
        handle_ = std::fopen(filename, mode);
    }

    ~File() {
        if (handle_) {
            std::fclose(handle_);
        }
    }

private:
    File(const File&);            // 只声明，不实现
    File& operator=(const File&); // 只声明，不实现

    std::FILE* handle_ = nullptr;
};
```

这样一来，外部代码一旦写出 `File f2 = f1;` 或者 `f2 = f1;`，就会因为尝试调用一个 `private` 成员函数而在编译阶段报错。即便有些情况下能通过编译，在链接阶段也会因为缺少实现而失败。

这个技巧确实能达到“禁止复制”的目的，但有几个明显的问题：

它依赖于“访问控制”和“链接错误”这两层机制来间接阻止错误用法，不够直观。  
看代码的人很难第一眼看出“这个类就是不允许拷贝”，因为所有关键的信息都藏在 `private` 下面。  
一旦后来你忘记了这个设定，想给它加个复制实现，还要去找这两个声明、删掉它们，再写新的函数体。

C++11 给了我们一个更直接的表达方式：用 `= delete` 告诉编译器，“这个函数在语义上就不允许被调用”。

### 用 = delete 明确地说：“这个函数禁止使用”

还是同一个 `File` 类，如果我们用 C++11 的写法，可以把“禁止复制”的意图写得非常直接：

```cpp
class File {
public:
    File(const char* filename, const char* mode) {
        handle_ = std::fopen(filename, mode);
    }

    ~File() {
        if (handle_) {
            std::fclose(handle_);
        }
    }

    File(const File&) = delete;             // 禁止复制构造
    File& operator=(const File&) = delete;  // 禁止复制赋值

private:
    std::FILE* handle_ = nullptr;
};
```

这两行的意思非常字面化：`File(const File&)` 这个函数是被“删除了”的，只要有人试图调用它，就一定是编译错误。这和藏在 `private` 里的那种写法不同，它不是“你虽然声明了一个函数，但外面访问不到”，而是“这个函数在设计上就不提供”。

现在，如果有人写出这样的代码：

```cpp
void bad() {
    File f1("data.txt", "w");
    File f2 = f1;       // 这里会因为调用了被 delete 的构造函数而报错
}
```

编译器会明确告诉你：尝试调用了一个被 `= delete` 标记的函数。错误信息本身就已经在“讲道理”了，很容易理解。

同样地，如果你再写：

```cpp
void bad_assign() {
    File f1("data.txt", "w");
    File f2("data.txt", "w");
    f2 = f1;            // 同样会在编译时报错
}
```

一样会被禁止。

在现代 C++ 代码里，你经常会看到类似这样的模式：

```cpp
class NonCopyable {
public:
    NonCopyable() = default;
    ~NonCopyable() = default;

    NonCopyable(const NonCopyable&) = delete;
    NonCopyable& operator=(const NonCopyable&) = delete;
};
```

任何继承了 `NonCopyable` 的类，都会自动变成“不能复制”的类。这种写法简洁、直白，读取成本很低。

### 不只是类成员：用 = delete 禁止某些调用方式

`= delete` 不仅可以用在类的特殊成员函数上，也可以用在普通函数上，用来“禁止某种特定的调用方式”。

举一个和隐式类型转换有关的例子。假设你有一个函数，只希望接收 `double`，不希望有人把 `int` 直接传进来（虽然按语言规则可以隐式转换），你可以这样写：

```cpp
void print_double(double x) {
    std::printf("value = %f\n", x);
}

void print_double(int) = delete;
```

这里我们提供了一个正常版本的 `print_double(double)`，又提供了一个“被删除”的重载 `print_double(int)`。如果有人写：

```cpp
int main() {
    print_double(3.14);  // 调用 double 版本：正常
    print_double(10);    // 尝试调用 int 版本：编译错误
}
```

对 `3.14` 的调用会选择 `double` 版本，一切正常；对 `10` 的调用，本来可以按规则转成 `double`，但因为你专门为 `int` 提供了一个“被删除”的重载，编译器就会优先匹配到这个 `int` 版本，然后发现它是 `= delete` 的，于是报错。这样你就用非常直接的方式，禁止了一类你不希望发生的调用。

类似的技巧也可以用来禁止某些“危险”的指针转换、禁止从某些类型向另一些类型隐式构造等。只要你觉得“这个函数从语义上绝对不该被调用”，用 `= delete` 标记是一个很好的选择。

### 小结：= default 和 = delete 都是在“跟编译器讲清楚话”

从 C 到 C with class，再到 C++11，编译器帮你干的事情越来越多，默认规则也越来越复杂。`= default` 和 `= delete` 看起来只是两个简单的标记，但背后表达的是一种更“显式”的设计风格。

当你写下 `= default` 时，你是在告诉编译器：“这一项你就按你熟悉的标准版本来生成，我只是想把它明确地写出来，让所有人都知道我确实需要这个默认行为。”

当你写下 `= delete` 时，你是在告诉编译器：“从语义上讲，这个函数就不应该被调用。任何试图调用它的代码都是错误的，请帮我在编译阶段就把它拦下来。”

理解这些之后，当你再遇到“我只是多写了一个构造函数，为什么就没有默认构造了？”、“这个资源类被不小心复制了一份怎么办？”之类的问题时，就可以不再揣测编译器的“脾气”，而是用这两个小语法，清清楚楚地把自己的意图写到代码里。