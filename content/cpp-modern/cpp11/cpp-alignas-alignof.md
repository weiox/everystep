---
title: 'alignas / alignof：对齐这事别再靠猜'
description: 'C++11 给了 alignof 和 alignas，让你能用标准语法查询/指定对齐，不再依赖编译器扩展和 #pragma。'
---

那会儿我们写 C。

也写一点 C with classes。

项目不大。

胆子很大。

内存就是一块大数组。

指针就是一把万能钥匙。

你拿它能开门。

也能撬锁。

更能把自己锁屋里。

我们那时候最爱说一句话。

“这不就是几个字节嘛。”

然后现实就会补一句。

“对。
但你得排队站好。”

当年没有 `alignof`。

也没有 `alignas`。

你想知道一个类型“站队站多齐”。

只能靠猜。

靠试。

靠同事口口相传。

最后靠线上报警。

啪一下。

你才知道。

原来有些机器很讲规矩。

地址不对齐。

它就当场罢工。

### 当年我们怎么把自己坑进 ICU

先把“对齐”这词掰开。

你可以把内存想成一排地砖。
有的类型喜欢站在“整块砖”的边界上。
不让它站好，它就别扭。

最常见的坑。
不是你写错算法。
是你把一段字节，当成了一个 `int`。

比如你写了个小项目。
自己做个“二进制小协议”。
为了省空间，你把结构体压紧。

这里的 `#pragma pack` 你可以先当成一句“拜托编译器把它们挤紧点”。
它不是 C++ 标准的一部分。
所以它也会带来“平台味”。

```cpp
#pragma pack(push, 1)
struct Msg {
    char tag;
    int  value;
};
#pragma pack(pop)
```

看起来很美。
`sizeof(Msg)` 变小了。
你还以为自己很会省流量。

但 `value` 可能落在一个“不该落的位置”。
在某些环境里，读它会直接崩。
不是逻辑错，是进程没了。

再狠一点。
你甚至会把网络包当成 `Msg*`。

```cpp
const unsigned char* buf = get_packet();
auto m = reinterpret_cast<const Msg*>(buf);
return m->value;
```

这段代码的味道，老同事闻一眼就皱眉。
它不只是“可能不对齐”。
它还是 C++ 里经典的未定义行为。

“未定义行为”的意思是。
标准没保证会发生什么。
你今天跑得过。
明天换台机器就可能当场炸。

还有一个点。
`reinterpret_cast` 这种强转，你可以理解成一句“你别问，我很确定”。
编译器真的会信你。
但出了事也不会替你兜底。

当年大家怎么从坑里爬出来？
靠经验。
靠“别这么写”。
再加几套平台专用的宏。

### 没有标准工具的年代：对齐像口音

你想让某个东西更对齐。
就去找编译器的私货。

有的写 `__attribute__((aligned(16)))`。
有的写 `__declspec(align(16))`。
还有一堆 `#pragma pack`，像调音台一样乱拧。

你想问一句。
“这个类型到底要求几字节对齐？”
很抱歉，没有统一问法。

于是对齐就变成了“口音”。
同一句话，不同编译器说出来不一样。

### alignof：终于能把问题问清楚

`alignof(T)` 的意思很朴素。
它告诉你：类型 `T` 这种人，站队最少要站多齐。

它给你的是一个编译期常量。
也就是，编译器在编译的时候就能算出来。

```cpp
struct S {
    char c;
    int i;
};

static_assert(alignof(S) >= alignof(int), "");
```

你不需要“凭感觉”。
你可以写断言。
让代码替你记住规矩。

更现实的用法，是你自己搞一段缓冲区。
然后想在里面“放一个对象”。

```cpp
alignas(1) unsigned char buf[64]{};
auto p = reinterpret_cast<S*>(buf + 1);
```

这段代码只是为了“复现问题”。
它展示的是：对齐不够，连“读一下”都可能出事。
真工程里别用这种方式去伪造对象。

`buf + 1` 基本可以确定“不对齐”。
这时候你至少该意识到：你在玩火。
`alignof(S)` 就是你的温度计。

一句话成段。

别拿“能跑”当“正确”。

### alignas：终于能把要求说出口

`alignas(N)` 的意思也不玄。
它告诉编译器：这个类型（或这个变量），我要它按 `N` 字节对齐。

你常见的动机，可能不是性能优化。
而是“我不想再踩坑”。

比如你做了个简单的对象池。
为了省事，你用 `char` 数组自己管理内存。

```cpp
unsigned char pool[128]{};
auto p = reinterpret_cast<S*>(pool + 1);
```

你以为你只是“挪了一个字节”。
但你其实是在让 `S` 站在一块歪砖上。

你可以换个做法。
先把缓冲区本身对齐。

```cpp
alignas(S) unsigned char pool[128]{};
auto p = reinterpret_cast<S*>(pool);
```

`alignas(S)` 不是让你更快。
它先让你更稳。

再比如你想让一个计数器单独站一边。
别跟别的变量挤在一起。

```cpp
struct alignas(64) Counter {
    std::uint64_t value;
};
```

这里的 `64` 你可以理解成“给它留个大点的位置”。
避免大家挤来挤去。
当然，你也可以不关心这个细节。

关键是：你有标准语法能表达这个要求。

### 小心点：alignas 不是随便许愿

`alignas` 只能指定“合理”的对齐值。
通常你会看到 1、2、4、8、16 这种。

你也不能用它把对齐降到低于类型本身需求。
你说“我就想让 `int` 1 字节对齐”。
编译器大概率会拒绝你。

这不是编译器小气。
这是它在替你守规矩。

### 最后一个洞见

对齐这事，最阴的是它的反馈机制。
你写错了。
它不一定立刻报错。

它可能在你换了个环境。
换了个编译器。
或者只是线上某个输入“刚好碰到”。

然后啪一下。

所以 C++11 这两个关键字的价值，不是“炫技”。
是把“规矩”变成“代码能表达的契约”。

一句话成段。

契约写进代码里。

别写进传说里。
