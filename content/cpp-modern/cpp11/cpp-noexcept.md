---
title: 'noexcept：异常规格说明的现代写法'
description: 'C++11 用 noexcept 取代 throw()，让“我不会抛异常”变成编译器能信的承诺，也直接影响移动语义的性能。'
---

异常这东西。

你学 C 的时候。

它像个“错误返回值”。

你学 C with classes 的时候。

它突然变成“会跳走的炸弹”。

然后你就会想。

能不能把它管住。

能不能让一个函数。

像合同一样。

写清楚：我会抛什么。

写清楚：我不会抛什么。

### 那一年，大家还在写 throw()

很久以前。

标准给过我们一个看起来很“正经”的语法。

写在函数后面。

像盖章。

```cpp
void f() throw(std::bad_alloc);
```

意思是：

我最多就抛这个。

别的都不抛。

听起来很稳。

像老派工程师最爱的那种稳。

### 坑的味道：写了也不等于管住了

现实很快就开始打脸。

编译器大多数时候，不会因为你写了这句，就突然变聪明。

它很难用这东西做优化。

而你最想要的“约束”，也不是真的静态检查。

它更像一个运行时的“誓言”。

你要是违约。

就会触发一个很古早的机制：`std::unexpected`。

这个名字翻译过来其实挺贴切。

标准库看着你抛出来的异常，会说：

“这不对劲。”

然后默认做一件更不对劲的事：结束进程。

### 茶水间事故：线上啪一下就没了

我见过最离谱的事故。

不是抛异常。

是“我以为我抛了异常”。

结果程序直接没了。

```cpp
void report() throw() {
    throw 42;
}
```

你以为这就是个错误。

抓一下就行。

实际上你写了 `throw()`，意思是“我什么都不抛”。

你又真的抛了。

那标准库就直接 `std::terminate()`。

一句“回滚”“降级”“兜底”，都来不及。

有时连日志都没刷出来。

你站在茶水间，端着杯子，脑子里就一个字：

“啊？”

### C++11 的态度：别装能检查，直接把规则说死

C++11 做了一件很务实的事。
它没有继续修补那套 `throw(T...)`。
而是把“不会抛”这件事，改成一个更干脆的关键字：`noexcept`。

```cpp
void g() noexcept {
    // ...
}
```

它的逻辑很直。
你说你不抛，你就必须不抛。
一旦抛了，还是 `std::terminate()`。

区别在于，这次没人再假装“我能帮你处理 unexpected”。
规则写死。
编译器也就敢信，标准库也就敢押注。

关键结论先放这。

`noexcept` 不是给人看的。

它是你跟编译器、跟标准库打的一个赌。

### 第二个更阴的坑：你写了 move，却没用上

讲个更像“线上”的。
我写过一个小项目，读日志，解析成对象，丢进 `std::vector`。
压测一跑，CPU 飙了。

我第一反应是 move 写错了。
结果 move 没错。
是标准库根本不敢用。

```cpp
struct S {
    S() = default;
    S(const S&) { puts("copy"); }
    S(S&&) { puts("move"); } // 没写 noexcept
};
```

再来两行。

```cpp
std::vector<S> v;
v.push_back(S{});
v.push_back(S{}); // 这里很可能触发扩容
```

你以为会看到 `move`。
很可能你看到的是一堆 `copy`。
原因不玄学。

`vector` 扩容时，要把旧元素搬到新内存。
如果搬一半你抛了异常，它就很难保证“要么全成功，要么啥也没发生”。
这叫异常安全，你先把它当成一句人话：我不能把你数据搞一半就跑。

所以标准库有个老实人的策略。
搬家这件事，如果 move 可能抛，那我宁愿 copy。
因为 copy 这条路，它更容易兜住局面。

解决也很朴素。
你真能保证不抛，就把赌注写上去。

```cpp
S(S&&) noexcept { puts("move"); }
```

很多项目里，这一句的意思几乎等价于：

让 `vector` 扩容时真的走 move。

少这一句。

你以为你在用移动语义。

其实在用拷贝。

### 标准库到底在怕什么

它怕的是你把“可能失败的操作”塞进一个必须稳的流程里。
比如扩容，比如重新分配，比如搬家。

这类地方标准库宁愿保守，也不愿聪明。

因为聪明出错。

代价是你线上啪一下。

### noexcept 还能写条件：我不拍胸脯，但我会写条款

当然。
不是每个 `noexcept` 都能拍胸脯。
模板一来，你就得看 `T` 的脸色。

C++11 允许你写“条件承诺”。

```cpp
template <class T>
void swap(T& a, T& b) noexcept(noexcept(T(std::move(a)))) {
    T tmp = std::move(a);
    a = std::move(b);
    b = std::move(tmp);
}
```

这里有个新东西：`noexcept(expr)`。
它会给你一个 `bool`，而且编译器能算出来。
意思是：这个表达式在语义上“保证不抛”吗？

所以这段话翻译成人话就是：
如果 `T` 的移动构造不抛，那我这个 `swap` 也不抛。
否则我就不乱承诺。

你写得保守一点。
标准库也能更大胆一点。

### 我写 noexcept 的小规矩

我不喜欢滥用 `noexcept`。
因为它不是注释，它是合同。
你违约的代价，是直接结束进程。

但我也不喜欢回避。
因为它会改变标准库的行为，尤其是容器，尤其是移动。

所以我的规矩很简单。
能保证就写。
保证不了就别硬写。
模板里就写条件。

最后再给你一句老程序员的“茶水间总结”。

> `noexcept` 的价值，不是让你少抛异常。
>
> 是让别人敢相信你。
