---
title: 'static_assert：把断言搬到编译期'
description: 'C++11 给了 static_assert，让“这个类型/这个平台不行”在编译时就直接说明白。'
---

那会儿我刚从 C 走到 C with classes。

项目不大。

人也不多。

我们写代码的标准很简单。

能跑。

就算赢。

直到有一天。

同一份程序。

在我机子上不炸。

到了客户那台机器。

啪一下。

我去问原因。

没人能一句话说清。

### 当年没有 static_assert

这种“只在客户那台机器炸”的事。
我见多了就知道。
大概率不是你的 `if` 写反了。

它更像是。
有个规矩没人写下来。
然后某天被现实抽了一巴掌。

那会儿我们能用的，主要还是 C 时代那套。
也就是 `assert`。

它的逻辑很朴素。
程序跑到这里。
不满足就当场停下。

问题也很朴素。
它得跑到这里，才会停。

更坑的是。
很多项目会在发布版里把 `assert` 关掉。
你一旦定义了 `NDEBUG`，它就当场“蒸发”。

你写库。
你写工具。
你写一段“平时很少走到”的分支。
那这个断言就像没写。

所以当年大家开始琢磨一件事。

能不能让编译器早点知道。
别等我跑起来。
更别等我上线。

### 巫术时代：用编译错误当闹钟

没有现成工具。
那就自己造。

有人写宏。
有人玩模板。
甚至有人去用 Boost 这种“第三方大补丸”。

核心思想就一个。
让编译器报错。
拿编译错误当闹钟。

最常见的一个套路。
用数组长度逼编译器报错。

```cpp
typedef char must_be_64bit[(sizeof(void*) == 8) ? 1 : -1];
```

条件不成立。
数组长度就是 -1。
编译器就会报错。

能用。
但报错经常长这样。

“size of array is negative”。

你还得自己翻译一下。
“哦，原来我想要 64 位”。

这就是那个年代的日常。
能活。
但活得不体面。

### C++11：把这件事说人话

后来 C++11 给了 `static_assert`。

它做的事不新鲜。
新鲜的是：它把话说清楚了。
而且是在编译期。

你没跑起来。
编译器先替你吵一架。

它具体长什么样。
我们放到后面结合事故再看。

### 线上啪一下：一个小项目就够了

当时我们写了个很小的功能。
把内存里的数据直接写进文件。
第二天再读出来。

代码大概长这样。

```cpp
struct Record {
    int id;
    void* ptr;
};
```

你别笑。
这种“先写起来再说”的代码，每个人都写过。

先不写文件。
光看 `sizeof` 就够复现了。

```cpp
printf("%zu\n", sizeof(Record));
```

你在 64 位上跑一次。
可能是 16。

你在 32 位上跑一次。
可能是 8。

这时候你才需要去追问。
为什么同一个 `struct`，会变？

答案也不玄学。

32 位 / 64 位。
你先把它理解成：指针（地址）在内存里占几字节。

32 位机器，指针通常是 4 字节。
64 位机器，指针通常是 8 字节。

`Record` 里有个 `void*`。
所以它的大小很容易跟着平台一起变。

再加上编译器为了跑得快。
会在字段之间塞一些“空隙”。
这叫 padding（填充）。

然后我们把它写进文件。

```cpp
Record r{42, nullptr};
fwrite(&r, sizeof(r), 1, fp);
```

在开发机上，一切正常。
上线后客户用的是 32 位环境。
文件里的布局变了。

你读出来的东西就开始错位。

错位这种事很讨厌。

它不一定立刻崩。
它可能只是悄悄把数据读歪。
等你拿歪掉的数据去当指针用，就“啪”。

### 我们当时当然也写断言

第一反应很朴素。

加个 `assert`。

```cpp
assert(sizeof(void*) == 8);
```

意思是。

“我只支持 64 位。”

但它有个致命的问题。

它得跑到这一行。
才会告诉你“不对”。

也就是说。
它属于“运行期检查”。
先跑起来，再验证。

你想想线上最常见的尴尬：

那一行不一定会被跑到。

或者跑到的时候。

已经是凌晨三点。

### static_assert：让编译器先吵起来

C++11 给了一个更狠的东西。

`static_assert`。

它像是你在代码里塞了一个“门禁”。

刷不过。

连可执行文件都不让你出门。

```cpp
static_assert(sizeof(void*) == 8, "need 64-bit");
```

这一行的意思很直白。
如果指针不是 8 字节。
编译直接失败。

这就是“编译期检查”。
程序还没跑。
编译器先把你拦住。

有点残忍。

但很负责。

> 有些错误。
>
> 早点失败。
>
> 比晚点成功更便宜。

### 再给一个更贴近现实的例子

更常见的不是“你支持不支持 64 位”。

而是“我这个数据格式是不是被你改坏了”。

比如你有个文件头。

你希望它永远是 8 字节。

```cpp
struct Header {
    std::uint32_t magic;
    std::uint16_t version;
    std::uint16_t flags;
};
```

你在旁边立一块牌子。

```cpp
static_assert(sizeof(Header) == 8, "Header layout changed");
```

以后谁要是手滑。

往 `Header` 里多塞一个字段。

或者调整了字段顺序。

编译器会第一个跳出来骂人。

你不用等测试。

也不用等线上。

这比 code review 的肉眼靠谱。

### 它能断言什么，不能断言什么

`static_assert` 只做一件事。

断言“编译期就能算出来”的东西。

像 `sizeof(...)` 这种。

编译器现在就能算。

就能断言。

但你别拿它断言运行时输入。

先说一个能过的。
你把值写成 `constexpr`（编译期常量）。

```cpp
constexpr int x = 42;
static_assert(x > 0, "x must be positive");
```

这时候编译器能在编译期算出 `x`。
所以它能断言。

但下面这样就不行。
哪怕你觉得它“看起来也是 42”。

```cpp
int x = 42;
static_assert(x > 0, "x must be positive");
```

看起来 `x` 写死了。
但它还是一个“运行时变量”。
编译器不会把它当成编译期常量。

因为 `x` 的值。
得程序跑起来才算数。

这不是 `static_assert` 的工作。

它更像是。

你在设计上立的规矩。

让编译器替你盯着。

`static_assert` 的价值。
很多时候不是“能不能做到”。
而是“能不能把话说清楚”。

它把那些“只存在于老同事口头交接里的规矩”。
变成了编译器每天都能检查的规则。
这其实是一种很朴素的工程进步。

### 最后一句话

你写下 `static_assert`。

其实是在给未来的人留路标。

未来的你。

未来的同事。

还有未来那个凌晨三点被电话叫醒的人。

让编译器替你把架吵完。

你就少一次去线上道歉的机会。
