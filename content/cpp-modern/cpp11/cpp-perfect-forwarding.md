---
title: '完美转发与 std::forward：把参数“原样”传下去'
description: 'C++11 让模板包装器不再“把右值变左值”：万能引用 T&& + std::forward 保留值类别，既不多拷贝也不误用重载。'
---

写库写久了。

你总会写出一种函数。

它不干正事。

它只负责转发。

比如加日志。

比如计时。

比如做一次统一的异常处理。

如果你是刚学完 C with classes 的同学。

你可能会觉得。

“转发还能有什么坑。”

不就是把参数再传下去吗。

但这件事在 C++ 里。

之所以值得写一整篇。

是因为它牵扯到一个很反直觉的点。

参数到了你手里。

它可能会悄悄变味。

这类函数最容易翻车。

因为它看起来很简单。

但它经常把“右值”悄悄变成“左值”。

然后性能没了。

重载也选错了。

这里先把“左值/右值”用人话说清楚。

你不用背定义。

你只需要记一个感觉。

有名字的东西。

通常就是左值。

临时的东西。

通常就是右值。

还有一句更好用。

> 在函数体里。
>
> 只要你给它起了名字。
>
> 它就更像左值。

## 先看一个很真实的坑

```cpp
template <class F, class T>
auto call(F f, T t) {
    return f(t);
}
```

你以为 `call` 很无辜。

但如果你这样用。

```cpp
std::string make();

call([](std::string&&) {}, make());
```

`make()` 返回的是右值。

到了 `call` 里。

`t` 有名字。

有名字就变成左值。

于是你原本想调用的 `f(std::string&&)`。

可能就调用不到了。

这就是模板包装器最常见的“隐形降级”。

如果你想把这个坑讲得更直白。

可以加两个重载。

你一眼就能看见“选错了”。

```cpp
void sink(const std::string&) {
    std::cout << "lvalue\n";
}

void sink(std::string&&) {
    std::cout << "rvalue\n";
}
```

然后你写一个天真的包装器。

```cpp
template <class T>
void wrap(T&& x) {
    sink(x);
}
```

你以为传右值会走右值重载。

但 `x` 有名字。

所以它会走左值那条路。

## 万能引用：T&& 的另一面

当 `T&&` 出现在模板参数推导里。

它不是普通的右值引用。

它会根据实参。

推导成左值引用或右值引用。

```cpp
template <class T>
void sink(T&& x);
```

传左值。

`T` 推导成 `U&`。

`T&&` 折叠成 `U&`。

传右值。

`T` 推导成 `U`。

`T&&` 就是 `U&&`。

你不用背完规则。

记一句就够了。

> 这是为了“接住一切”。

但“接住”只是第一步。

你还得“原样交出去”。

## std::forward：把你接到的东西原样交出去

`std::move` 是强行变右值。

`std::forward` 是条件性的。

如果你刚开始分不清。

可以先用一句话粗暴区分。

`move` 是“我不管你原来是什么，我就当你是右值”。

`forward` 是“你原来是什么，我就还你是什么”。

它会按照 `T` 的推导结果。

决定到底转成左值还是右值。

于是正确的转发写法是。

```cpp
template <class F, class T>
auto call(F&& f, T&& t) {
    return std::forward<F>(f)(std::forward<T>(t));
}
```

你看。

参数也得是 `F&&`、`T&&`。

而不是值传递。

否则你前面已经把东西复制了一遍。

后面再 forward 也没意义。

## 一个很工程的例子

你想写一个统一创建对象的工厂。

C++11 没有 `make_unique`。

但你可以自己写。

```cpp
template <class T, class... Args>
std::unique_ptr<T> make(Args&&... args) {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}
```

这里 `Args&&...` 接住一切参数。

`std::forward<Args>(args)...` 原样传给构造函数。

左值还是左值。

右值还是右值。

你不会因为写了一个工厂。

就让某些构造函数的重载永远选不到。

也不会因为“多拷贝一次”。

把性能葬送在创建对象这一步。

## 小洞见

完美转发这词听起来很大。

但它解决的其实是一个很朴素的问题。

当你写包装器。

你不该改变别人传进来的语义。

你只是在路上加了一盏灯。

不是把车换成了牛车。

所以我一直把 `std::forward` 当成一种自律。

你写库代码。

就别在无意间替用户做决定。
