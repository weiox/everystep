---
title: '完美转发与 std::forward：把参数“原样”传下去'
description: 'C++11 让模板包装器不再“把右值变左值”：万能引用 T&& + std::forward 保留值类别，既不多拷贝也不误用重载。'
---

在 C++11 之前。

写模板包装器是一件很“朴素”的事。

你要么值传递。

你要么写成 `const T&`。

看起来都没毛病。

直到我开始写一个小项目。

它不大。

就是一个小小的工具库。

专门把用户传进来的函数包一层。

顺手加日志。

顺手计时。

顺手统一异常。

开始把同一个接口。

分成“拿左值”和“拿右值”两条路。

然后某天线上啪一下。

本来该走右值那条路的调用。

突然走到了左值那条路。

性能掉了。

还选错了重载。

你回头看包装器。

它很短。

它甚至很“无辜”。

因为你只是把参数再传了一次。

问题在于。

C++ 有个很坏的脾气。

东西一旦到了函数体里。

只要你给它起了名字。

它就更像左值。

这里先把“左值/右值”用人话说清楚。

你不用背定义。

你只需要记一个手感。

有名字的。

通常更像左值。

临时的。

通常更像右值。

还有一句更好用。

> 在函数体里。
>
> 只要你给它起了名字。
>
> 它就更像左值。

### 事故现场：包装器把右值变左值

```cpp
template <class F, class T>
auto call(F f, T t) {
    return f(t);
}
```

你以为 `call` 很无辜。

它就是个中转站。

但如果你这样用。

```cpp
std::string make();

call([](std::string&&) {}, make());
```

`make()` 返回的是一个临时对象。

也就是我们常说的“右值”。

但到了 `call` 里。

它被装进了变量 `t`。

从这一刻开始。

`t` 就是个有名字的东西。

有名字的东西更像左值。

于是你原本想调用的 `f(std::string&&)`。

可能就调用不到了。

这就是模板包装器最常见的“隐形降级”。

如果你想把这个坑讲得更直白。

可以加两个重载。

你一眼就能看见“选错了”。

```cpp
void sink(const std::string&) {
    std::cout << "lvalue\n";
}

void sink(std::string&&) {
    std::cout << "rvalue\n";
}
```

然后你写一个天真的包装器。

```cpp
template <class T>
void wrap(T&& x) {
    sink(x);
}
```

你以为传右值会走右值重载。

但 `x` 有名字。

所以它会走左值那条路。

这件事特别反直觉。

因为你明明写的是 `T&&`。

看起来就是“右值引用”。

### 万能引用：T&& 的另一面

当 `T&&` 出现在模板参数推导里。
它不是普通的右值引用。
它会根据实参推导成左值引用或右值引用。

```cpp
template <class T>
void sink(T&& x);
```

传左值。
`T` 推导成 `U&`。
`T&&` 折叠成 `U&`。

传右值。
`T` 推导成 `U`。
`T&&` 就是 `U&&`。

你不用背完规则。
记一句就够了。

> 这是为了“接住一切”。

但“接住”只是第一步。

你还得“原样交出去”。

### std::forward：把你接到的东西原样交出去

`std::move` 是强行变右值。
`std::forward` 是条件性的。

如果你刚开始分不清。

可以先用一句话粗暴区分。

`move` 是“我不管你原来是什么，我就当你是右值”。

`forward` 是“你原来是什么，我就还你是什么”。

它会按照 `T` 的推导结果。

决定到底转成左值还是右值。

于是正确的转发写法是。

```cpp
template <class F, class T>
auto call(F&& f, T&& t) {
    return std::forward<F>(f)(std::forward<T>(t));
}
```

你看。

参数也得是 `F&&`、`T&&`。

而不是值传递。

否则你前面已经把东西复制了一遍。

后面再 forward 也没意义。

回到刚才那个 `wrap`。

这次你要做的事情其实很克制。

你不替调用者做决定。

你只是把它交回去。

```cpp
template <class T>
void wrap(T&& x) {
    sink(std::forward<T>(x));
}
```

`forward` 不会无脑把东西变成右值。

它只是在说。

“如果你当初给我的就是右值，那我就把右值还给下游。”

### 一个很工程的例子

你想写一个统一创建对象的工厂。

C++11 没有 `make_unique`。

但你可以自己写。

```cpp
template <class T, class... Args>
std::unique_ptr<T> make(Args&&... args) {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}
```

这里 `Args&&...` 接住一切参数。

`std::forward<Args>(args)...` 原样传给构造函数。

左值还是左值。

右值还是右值。

你不会因为写了一个工厂。

就让某些构造函数的重载永远选不到。

也不会因为“多拷贝一次”。

把性能葬送在创建对象这一步。

### 小洞见

完美转发这词听起来很大。

但它解决的其实是一个很朴素的问题。

当你写包装器。

你不该改变别人传进来的语义。

你只是在路上加了一盏灯。

不是把车换成了牛车。

所以我一直把 `std::forward` 当成一种自律。

你写库代码。

就别在无意间替用户做决定。

以后你看到“转发”。

脑子里可以先跳出一句话。

有名字的东西。

都像左值。

你得主动把它“还回去”。
