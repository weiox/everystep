---
title: '委托构造与继承构造：构造函数不再写到手抽筋'
description: 'C++11 让构造函数能“互相调用”，也让派生类能直接继承基类构造函数，把重复初始化从代码里赶出去。'
---

构造函数这玩意。

你写得越久。

越容易写出一种味道。

不是优雅。

是疲惫。

因为你总在重复。

重复同一串初始化。

重复同一套参数校验。

重复同一段“我保证对象是合法的”。

然后某一天。

你改了一个成员。

忘了改另一个构造函数。

bug 就开始在深夜发芽。

这不是新手才会犯。

这是语言语法逼出来的。

C++11 之前。

构造函数不能直接调用另一个构造函数。

你想复用逻辑。

只能用“曲线救国”。

比如抽个 `init()`。

```cpp
struct Log {
    int level;
    std::string path;

    Log() { init(1, "app.log"); }
    Log(int lv) { init(lv, "app.log"); }

    void init(int lv, const std::string& p) {
        level = lv;
        path = p;
    }
};
```

能用。

但你会很不舒服。

因为 `init()` 是一个普通成员函数。

它跑的时候。

对象已经构造到一半了。

成员的初始化时机。

也被你从初始化列表挪到了函数体。

很多类到了这里。

就开始引入更多“半初始化状态”。

而 C++ 的半初始化。

往往很贵。

也很危险。

## 委托构造：让构造函数调用构造函数

C++11 给了一个很朴素的能力。

构造函数可以委托给另一个构造函数。

你终于能写出“一个入口负责干活，其他入口只是转发”。

```cpp
struct Log {
    int level;
    std::string path;

    Log(int lv, std::string p)
        : level(lv), path(std::move(p)) {}

    Log() : Log(1, "app.log") {}
    Log(int lv) : Log(lv, "app.log") {}
};
```

这段代码的手感很对。

因为初始化还是在初始化列表里。

对象从第一口气开始就是完整的。

而你少写了重复。

少写的往往不是字符。

是未来的分叉。

> 重复的构造函数。
>
> 本质上是在复制 bug。

委托构造还有一个隐藏好处。

你可以把“不变量”集中在一个地方。

比如。

路径必须非空。

level 必须在范围内。

你只在主构造函数里检查一次。

其他构造函数天然就“跟着对”。

## 继承构造：派生类别再手抄基类构造函数

写过继承体系的人都懂。

最烦的不是虚函数。

是构造函数。

基类有三四个构造函数。

派生类只想“原样暴露”。

结果你得在派生类里手写一堆转发。

```cpp
struct Base {
    Base(int);
    Base(std::string);
};

struct Derived : Base {
    Derived(int x) : Base(x) {}
    Derived(std::string s) : Base(std::move(s)) {}
};
```

你会觉得自己像复读机。

C++11 的继承构造很直接。

一个 `using`。

```cpp
struct Derived : Base {
    using Base::Base;
};
```

派生类就把基类的构造函数“搬过来”。

不是复制粘贴。

是真正继承。

你少写很多样板。

而且重构的时候也不容易漏。

## 一个老程序员的提醒

委托构造和继承构造。

都很省事。

但省事不等于没边界。

委托构造的核心价值是。

把不变量集中在一个地方。

你别把它用成“到处绕来绕去”。

让人读起来像迷宫。

继承构造的核心价值是。

派生类只是“加点料”。

而不是改基类的构造语义。

如果派生类需要额外约束。

你可能还是得自己写构造函数。

把意图说清楚。

构造函数这块。

C++11 不是给你更多花样。

它只是把工程里最常见的重复。

变成了语言级的能力。

你用好了。

代码会更像一个整洁的工厂。

不是一个手工作坊。
