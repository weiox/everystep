---
title: '移动语义与右值引用：告别不必要的拷贝'
description: 'C++11 把“临时对象的资源”正规化成移动语义：T&&、std::move、move ctor/assign 让容器和返回值都跑得更轻。'
---

那会儿我们写 C++。

还不叫 C++11。

还叫 C++03。

大家对“对象拷贝”这件事。

有一种很天真的信任。

觉得它应该不贵。

反正代码看起来很干净。

然后线上就教你做人。

### 当年还没有它的时候

你想把一堆数据组装好，然后把结果作为返回值交给调用方。

业务代码里太常见了。

你写得很干净，接口也很舒服。

可在 C++11 之前，这段干净的代码经常贵得离谱。

它可能在你看不见的地方偷偷拷贝大对象。

更糟的是，你还以为这事应该由编译器替你“顺手做掉”。

### 事故来了

我们当时在做一个小服务，请求进来就组装一大坨字符串再吐出去。

机器没宕，CPU 也不高。

延迟却像被谁掐住了脖子。

排查到最后，罪魁祸首特别无辜：就是“返回值 + 接住它”。

### 当年的人怎么想

他们的选择并不蠢，只是活在那个年代的语言里。

C++03 没有把“临时对象快死了”写进规则。

编译器能不能省掉那次拷贝，你得靠运气，也得靠技巧。

运气不好时，你就会在热路径上复印大对象。

### 用最短代码把坑复现出来

如果你想看得更清楚，就让返回值里装一个“很难拷贝得便宜”的东西。

比如一个很大的 `std::string`。

```cpp
std::vector<std::string> build() {
    std::vector<std::string> v;
    v.push_back(std::string(10000000, 'x'));
    return v;
}

auto x = build();
```

在没有移动语义的年代，`return v;` 如果没被优化掉，就可能意味着“再分配一次大内存，再拷一遍内容”。

你写的是“把结果交出去”，机器做的却像“再复印一份”。

### 大家怎么从坑里爬出来

最朴素的修补是别返回，改成输出参数。

再用 `swap` 把结果换出去。

```cpp
void build(std::vector<std::string>& out) {
    std::vector<std::string> tmp;
    tmp.push_back(std::string(10000000, 'x'));
    out.swap(tmp);
}
```

它确实能快，因为 `swap` 通常只是换几个指针。

可接口也会变别扭，你开始到处传引用，到处担心对象是不是被谁顺手改了。

### 这时候概念才登场

C++11 做的事其实很朴素。

它承认一个现实：临时对象快死了。

它手里的资源与其拷贝一份，不如直接搬走。

这个“搬走”。

就叫移动语义。

### 右值引用：专门接“快死的东西”

先把词拆开。

左值大概就是“有名字、你还能再用”的对象。

它通常能取地址。

右值大概就是“你用完这一行它就没了”的东西。

函数返回的临时对象和表达式的中间结果都算。

C++11 增加了 `T&&`，叫右值引用。

它的意义很单纯：告诉编译器和库，这东西快死了，可以把它的资源搬走。

### std::move：它不是移动

`std::move` 这个名字很会骗人。

它不搬家，只是把你手里的表达式打上“右值”的标签。

你写 `std::move(s)` 的意思更像是：我允许你从 `s` 里偷资源。

```cpp
std::string s = "hello";

auto t = std::move(s);
```

真正发生移动的地方，是 `std::string` 的移动构造/移动赋值。

它看见右值就倾向于“接管内部指针”，而不是“复制字符”。

### 放回刚才那个事故现场

你会开始看到一种很常见的写法：按值接收，再 move 进容器。

```cpp
void push(std::vector<std::string>& v, std::string s) {
    v.push_back(std::move(s));
}
```

`s` 在函数体里虽然是个左值，但它马上就要离开作用域。

把它 move 进去，语义很诚实：“我不再需要 `s` 了。”

### 你要为移动写什么

如果你自己管理资源，你通常要写两样东西：移动构造与移动赋值。

它们做的事情也单纯：接管指针，并把对方置空。

```cpp
struct Buf {
    char* p = nullptr;
    explicit Buf(std::size_t n) : p(new char[n]) {}
    Buf(Buf&& o) noexcept : p(o.p) { o.p = nullptr; }
    Buf& operator=(Buf&& o) noexcept {
        if (this != &o) { delete[] p; p = o.p; o.p = nullptr; }
        return *this;
    }
    ~Buf() { delete[] p; }
};
```

这就是“转交所有权”。

你把资源接过来，同时保证对方析构时不会二次释放。

### 移动之后的对象还能用吗

能。

但你只能指望它处于“有效但未指定状态”。

它还能析构，还能重新赋值，但你别再依赖它原来的内容。

```cpp
std::string a = "hi";
std::string b = std::move(a);

a = "again";
```

把它当成已经搬空的房子就好。

你可以再搬进去新的家具，但别再问旧沙发去哪了。

### 关键结论

移动语义不是让你到处写 `std::move`。

它是让“正常写法”终于也能快。

### 最后的亮点

你可以把拷贝想成复印。

把移动想成搬家。

复印当然也有用。

但你只是要把东西交给下一个人时。

搬走往往更诚实。
