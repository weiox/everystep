---
title: '移动语义与右值引用：告别不必要的拷贝'
description: 'C++11 把“临时对象的资源”正规化成移动语义：T&&、std::move、move ctor/assign 让容器和返回值都跑得更轻。'
---

我第一次真正体会到“拷贝很贵”。

不是在课本里。

是在一个线上故障里。

那天机器没宕。

CPU 也不高。

但延迟像被谁掐住了脖子。

最后我们定位到一个地方。

在热路径上。

不停地拷贝大对象。

代码长得很无辜。

```cpp
std::vector<std::string> build();

auto v = build();
```

你看。

这不是很正常吗。

返回一个 vector。

接住它。

可在 C++11 之前。

这类代码的性能。

很多时候靠运气。

靠编译器能不能把返回值“直接在目标位置构造好”。

也就是你看到 `return v;`。

它就别再偷偷拷贝一份。

靠你有没有写一些很别扭的绕路。

比如返回引用。

比如用输出参数。

靠你有没有“手动优化”。

C++11 做的事很朴素。

承认一个事实。

临时对象快死了。

它手里的资源。

与其拷贝一份。

不如直接搬走。

这就叫移动语义。

## 右值引用：专门接“快死的东西”

传统的引用是 `T&`。

它只能绑定到左值。

也就是有名字的对象。

C++11 增加了 `T&&`。

右值引用。

它更愿意绑定到临时对象。

比如返回值。

比如字面量拼出来的中间结果。

这类对象有个共同点。

你用完它。

它就要走了。

所以把它的资源搬走。

通常不需要内疚。

## std::move：它不是移动

这是最容易被误解的一句。

`std::move` 不会真的移动。

它只是把一个表达式。

强行标成右值。

```cpp
std::string s = "hello";

auto t = std::move(s);
```

真正发生移动的地方。

是 `std::string` 的移动构造。

它看见右值。

就选择“偷走指针”。

而不是“复制字符”。

这才是省下来的钱。

## 一个看得见的效果

你写一个函数。

把字符串塞进 vector。

```cpp
void push(std::vector<std::string>& v, std::string s) {
    v.push_back(std::move(s));
}
```

参数 `s` 在函数里是一个局部变量。

它马上就要析构。

你把它 move 进容器。

等于把资源交给容器。

少了一次分配。

少了一次拷贝。

而且语义很清楚。

“我不再需要 s 了。”

## 你要为移动写什么

通常是两样。

移动构造。

移动赋值。

```cpp
struct Buf {
    char* p = nullptr;

    Buf() = default;
    explicit Buf(std::size_t n) : p(new char[n]) {}

    Buf(Buf&& other) noexcept : p(other.p) {
        other.p = nullptr;
    }

    Buf& operator=(Buf&& other) noexcept {
        if (this != &other) {
            delete[] p;
            p = other.p;
            other.p = nullptr;
        }
        return *this;
    }

    ~Buf() { delete[] p; }
};
```

你看。

移动的本质就是“转交所有权”。

把指针拿过来。

把对方置空。

让析构安全。

## 移动之后的对象还能用吗

能。

但只能指望它处于“有效但未指定状态”。

讲人话。

你别再依赖它的内容。

你可以重新赋值。

可以析构。

但别拿它当原来的东西用。

```cpp
std::string a = "hi";
std::string b = std::move(a);

// a 的内容别再依赖
// 但你可以这样做
a = "again";
```

这条规矩很像现实。

你把钥匙交出去了。

你不能再假装钥匙还在你兜里。

## 一个小洞见

移动语义最值钱的地方。

不是让你到处写 `std::move`。

而是让库。

让容器。

让返回值。

默认就能更快。

你写得越像“正常代码”。

它收益越大。

这就是 C++11 很迷人的地方。

它不是教你更聪明。

它是让你少用小聪明。
