---
title: '用户自定义字面量：给单位和领域值一个“类型入口”'
description: 'C++11 的用户自定义字面量让 10ms、42km 这种表达变成类型安全的代码，也让“单位”不再只是注释。'
---

我见过最经典的单位 bug。

不是 C++ 独有。

但 C++ 特别容易中招。

因为你很爱用 `int`。

也很爱用 `double`。

然后你写出一个 `timeout = 500`。

你以为是毫秒。

同事以为是秒。

系统就变成了“有时很慢，有时很快”。

排查半天。

最后发现。

你们都没错。

错的是。

单位没进类型系统。

C++11 给了一个很有趣的工具。

用户自定义字面量。

它的价值不在花哨。

在于它把“单位”变成了语法。

变成了类型。

## 先从最容易踩坑的场景说起

超时。

延迟。

重试间隔。

这类东西在工程里特别常见。

而它最常见的 bug。

就是单位没说清楚。

你写了 `500`。

你以为是毫秒。

同事以为是秒。

然后系统就开始“偶尔很慢”。

用户还以为是网络问题。

你可以用用户自定义字面量。

把单位直接写进代码。

比如我们自己做一个 `_ms`。

```cpp
#include <chrono>

constexpr std::chrono::milliseconds operator"" _ms(unsigned long long v) {
    return std::chrono::milliseconds(v);
}
```

然后你就能写。

```cpp
auto timeout = 500_ms;
```

这行代码的意思很诚实。

500。

毫秒。

不是靠注释。

是写在字面量上。

## 自己写一个小字面量

工程里常见另一个单位。

是内存大小。

你写 `4096`。

别人不知道是字节还是 KB。

你可以定义一个 `_KB`。

```cpp
constexpr std::size_t operator"" _KB(unsigned long long v) {
    return static_cast<std::size_t>(v) * 1024;
}
```

然后你就能写。

```cpp
auto buf = 4_KB;
```

你不需要在脑子里乘 1024。

读者也不用猜。

## 它解决的不是语法问题

它解决的是沟通问题。

代码里最贵的 bug。

往往不是“算错”。

是“理解不一致”。

用户自定义字面量的意义。

就是把“理解”固化下来。

让编译器替你守门。

当然。

你也要克制。

别给每个数字都发一个后缀。

那会变成另一种噪音。

但当你遇到单位、领域值、协议常量这类东西。

字面量后缀往往是值得的。

因为它让代码像在说话。

不是像在猜谜。
