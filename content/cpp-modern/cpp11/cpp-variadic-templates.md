---
title: '可变参数模板：写一次，吃掉任意参数'
description: 'C++11 把“参数个数不固定”从宏和 va_list 里救出来：模板参数包让你写出类型安全的 printf、tuple、工厂与转发。'
---

在 C++11 之前。

你想写一个“吃任意参数”的函数。

大概有两条路。

一条路叫宏。

另一条路叫 `va_list`。

两条路都能用。

但都不太像 C++。

因为它们不讲类型。

如果你写过 C。

你大概率用过 `printf`。

它方便。

也危险。

你把格式串写错了。

或者你传错了类型。

编译器未必能救你。

```cpp
#include <cstdio>

std::printf("%d\n", "hello");
```

这段能不能当场炸。

取决于平台。

取决于实现。

也取决于你今天运气好不好。

更烦的是。

它不是每次都错。

所以你很难靠测试彻底覆盖。

C++11 的可变参数模板。

就是把这件事正规化。

让“任意参数”也在类型系统里。

你可以写一个日志函数。

接收任意类型。

但它仍然是类型安全的。

出错时也更好定位。

## 参数包：一个袋子

```cpp
template <class... Ts>
struct Pack;
```

`Ts...` 就像一袋类型。

你不知道它里面有多少个。

但你知道每一个是什么。

你可以把它想成。

不是 `void*` 的一袋。

而是一袋“有名字的类型”。

这就已经比 `...` 强太多了。

## 一个最经典的例子：打印

C++11 没有折叠表达式。

所以我们通常用递归展开。

这里初学者最容易卡的点是。

“为什么要有一个空的 print()？”

答案很朴素。

递归总要有个停止点。

参数吃完了。

就落到那个空函数上。

```cpp
#include <iostream>

void print() {}

template <class T, class... Ts>
void print(const T& x, const Ts&... xs) {
    std::cout << x;
    print(xs...);
}
```

你传进去多少个。

它就递归多少层。

每一层吃掉一个。

直到吃完。

如果你不写那个空的 `print()`。

编译器就不知道递归什么时候该停。

它会直接报错。

这不是模板很难。

这只是递归的基本规矩。

这段代码虽然朴素。

但它是很多库的起点。

日志。

格式化。

组合函数。

都绕不开它。

## 配合完美转发：才是真正的“库作者版本”

值传递会拷贝。

库作者不喜欢拷贝。

所以更常见的是。

```cpp
template <class... Args>
void log(Args&&... args) {
    print(std::forward<Args>(args)...);
}
```

这段 `...` 的意思。

你可以简单理解成。

“把袋子里的每个东西。

一个不漏地倒出来。”

你看。

可变参数模板很容易跟 `std::forward` 联手。

一个负责接。

一个负责原样交出去。

这就是 C++11 那种“特性之间互相咬合”的感觉。

## 小洞见

可变参数模板最厉害的地方。

不是让你写更复杂的模板。

而是让你把很多“只能用宏搞定”的接口。

变成正常函数。

能重载。

能推导。

能被 IDE 理解。

也能被类型系统保护。

这对工程来说。

是真正的解放。
