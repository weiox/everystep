---
title: '原始字符串与 Unicode 字面量：写正则和路径别再反斜杠地狱'
description: 'C++11 的原始字符串字面量 R"(...)" 让转义不再折磨人；u8/u/U 等 Unicode 字面量则把编码意图写进代码里。'
---

我一直记得第一次在 C++ 里写正则的感觉。

像在给反斜杠打工。

你想写一个很普通的 pattern。

结果代码里全是 `\\`。

你眼睛对着屏幕。

脑子在做两次解码。

一次是 C++ 字符串字面量。

一次是正则引擎。

然后你还得祈祷。

自己没少写一个反斜杠。

那会儿大家的共识很一致。

C++ 的字符串。

对人类不太友好。

C++11 做了一件很实用的事。

给了原始字符串字面量。

## 原始字符串：你写什么，它就是什么

看一段旧写法。

Windows 路径。

```cpp
auto path = "C:\\Program Files\\App\\data.txt";
```

这段没错。

但它让你很难一眼看出真实字符串。

C++11 以后。

你可以写成这样。

```cpp
auto path = R"(C:\Program Files\App\data.txt)";
```

这下就舒服了。

没有二次转义。

没有“数反斜杠”。

你看到的。

就是你想要的。

正则也一样。

比如一个很常见的“日期”。

```cpp
auto re = std::regex(R"(\d{4}-\d{2}-\d{2})");
```

你只需要按正则的规则写。

不用再同时满足 C++ 字符串的转义规则。

## 如果内容里刚好有 )"

你会问。

那我字符串里如果真的出现了 `)"` 呢。

C++11 也想到了。

原始字符串允许你自定义分隔符。

```cpp
auto s = R"tag( content )" and more )tag";
```

你给它一个 tag。

编译器就按 tag 配对。

这很实用。

因为你在嵌 JSON、SQL、正则的时候。

经常会碰到各种引号和括号。

## Unicode 字面量：把编码意图写出来

另一个老痛点。

是“这串字符到底是什么编码”。

有时候你觉得自己写的是 UTF-8。

结果某个环境把它当成系统代码页。

然后乱码就出现了。

C++11 给了几种字面量前缀。

你可以明确说。

我想要 UTF-8。

```cpp
auto s = u8"你好";
```

你也可以要 UTF-16。

```cpp
auto s16 = u"你好";
```

或者 UTF-32。

```cpp
auto s32 = U"你好";
```

它不保证世界上所有坑都消失。

但它至少让你能把意图写进代码。

而不是写进 README。

## 小洞见

原始字符串和 Unicode 字面量。

都不是“语言炫技”。

它们的目标很朴素。

让代码回到可读。

让字符串回到所见即所得。

你不需要在字符串里做心算。

你也不需要在编码问题上靠运气。

这就是 C++11 这种“工程化改进”最讨人喜欢的地方。
